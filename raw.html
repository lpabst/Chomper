<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Chomper</title>
    <!-- 
        If we release web view in the app, I can very easily make
        a mobile friendly 1-level version!
    -->
</head>

<body>
    <style>
        body {
            background: #222;
        }

        #startLevelText {
            color: #999;
        }

        #newGameButton {
            width: 200px;
            height: 50px;
            margin-bottom: 10px;
            box-shadow: 1px solid black;
        }

        #sectionHeader {
            text-decoration: underline;
        }

        .sectionBox {
            border: 1px solid white;
            padding-left: 10px;
            padding-bottom: 10px;
            color: #999;
            font-size: 15px;
        }

        .subItem {
            margin: 0px;
            padding-left: 20px;
        }

        .hasSubItems {
            margin-bottom: 2px;
        }

        #gameCanvas {
            background: black;
            width: 500px;
            height: 500px;
        }
    </style>

    <main>
        <canvas id="gameCanvas"></canvas>
        <div id="hideDuringGameplay">
            <p id="startLevelText">Start Level: <span><input id='gameLevelInput' /></span></p>
            <button id="newGameButton" onclick="Game.init()">Play Campaign</button>
            <button id='playCustomGameButton' onclick="Game.initCustom()">Play Custom Map</button>
            <button id='returnToEditorButton' onclick="drawEverything()">Return To Editor</button>
            <button id='resetEditorButton' onclick="resetEditor()">Clear/Reset Editor</button>
            <div id="rules" class="sectionBox">
                <h2 id="sectionHeader">How To Play</h2>
                <p>Clicking the 'Play Campaign' button will start the games built in levels. Read down below for info
                    about building your own levels</p>
                <p>Put any level number in the 'Start Level' input to begin playing on that level</p>
                <p>Use the arrow keys to move around. Try and eat the pieces of food on the board for points</p>
                <p>Different food colors are worth different amounts of points. Try and earn as many points as you can
                </p>
                <p>Enemies are red and will chase you. Each enemy has their strength & speed displayed, as do you</p>
                <p>If an emeny catches you, whoever has higher strength wins the fight. Ties go to the enemies</p>
                <p>Losing a fight to an enemy means losing a life. Run out of lives and the game is over</p>
                <p>After losing a life, your player becomes a ghost for a short time, during which you can move through
                    walls, but cannot use warp points or eat food or money </p>
                <p>Sometimes bad guys phase through walls. It's not a bug, it's a feature</p>
                <p>Eating all of the food on a level will take you to the next level</p>
                <p>Every now and then a green piece of food with '$$' written in it will appear for a short time. Eat it
                    for
                    money</p>
                <p>Press the *spacebar* to open and close the shop. Finishing a level will also open up the shop</p>
                <p>Money can be spent in the shop to buy powerups. </p>
                <p>*Note - you can trade your hard earned points for more money & vice-versa. The house always takes a
                    cut
                </p>
                <p>Yours and enemy's movement stops the while shop is open, but the game does not pause, meaning you
                    could
                    miss
                    money appearing while in the shop</p>
                <p>Blinking red dots are warp points that will transport you to stationary red dots. Only you can use
                    warp
                    points</p>
                <p>Food Bonus - if your food bonus is 2 and you eat a food worth 4 points, you will earn 6 points</p>
                <p>See how many points you can end the game with! Have fun</p>
            </div>
            <div id="editorHowTo" class="sectionBox">
                <h2 id="sectionHeader">How To Use The Editor</h2>
                <p>clicking on the map will place whatever the active item is onto the map at that location</p>
                <p>Press 'P' to make the active item the player object</p>
                <p>Press 'E' to make the active item an enemy object</p>
                <p>Press 'M' to make the active item a money object</p>
                <p class="hasSubItems">Press 'O' to make the active item a wall/obstacle object.</p>
                <p class="subItem">Note: you must click twice to build a wall, then it will build the wall between the
                    points you clicked on</p>
                <p class="subItem">Also Note: All walls are straight up/down or left/right, no diagonal walls can be
                    built</p>
                <p class="hasSubItems">Press 'F' to make the active item a food object.</p>
                <p class="subItem">Note: While the active item is food, you can click the numbers to build different
                    point valued food items</p>
                <p class="hasSubItems">Press 'W' to make the active item a warp object</p>
                <p class="subItem">Note: You must click twice to place a warp item. The first click places the entry
                    point, the 2nd click places the exit point</p>
                <p>Press 'D' to enter delete mode, where clicking on an object removes it from the editor. Pressing one
                    of the other command keys exits delete mode, for instance pressing 'F' will start putting food on
                    the board again</p>
                <p class="hasSubItems">Click on the 'Play Custom Map' button to try out your level you built!</p>
                <p class="subItem">Note: You must place the player and at least one piece of food for the custom map to
                    be playable</p>
            </div>
        </div>
    </main>
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"
        integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous">
        </script>
    <script>
        // set the w/h of the canvas
        var canvas = document.getElementById('gameCanvas')
        canvas.width = 500;
        canvas.height = 500;

        // types
        var WALL = 'WALL';
        var OBSTACLE = 'OBSTACLE';
        var PLAYER = 'PLAYER';
        var ENEMY = 'ENEMY';
        var FOOD = 'FOOD';
        var MONEYFOOD = 'MONEYFOOD';
        var HUDTEXT = 'HUDTEXT';
        var WARP = 'WARP';
        var LIVES = 'LIVES';
        var enemyType = {
            NORMAL: 'NORMAL', // default
            TANK: 'TANK', // slow and increased strength
            SPEEDY: 'SPEEDY', // fast and decreased strength
            FLOATER: 'FLOATER' // slow and can go through walls
        }

        // HUD area 0 - 140 && 0 - 88
        var hudWalls = [[0, 90, 150, 8, true], [150, 0, 8, 98, true]];
        var edgeWalls = [
            [0, 0, canvas.width, 8, true], // top
            [0, 0, 8, canvas.height, true], // left
            [0, canvas.height - 8, canvas.width, 8, true],
            [canvas.width - 8, 0, 8, canvas.height, true]]

        // entities per level map
        var entitiesForLevel = {
            1: {
                playerStartLocation: { x: 36, y: 124 },
                obstacles: [[100, 102, 8, 266], [194, 198, 8, 291], [72, 422, 190, 8], [157, 98, 8, 40], [156, 138, 109, 8], [293, 66, 8, 299], [292, 365, 8, 61], [298, 421, 142, 8], [355, 380, 94, 8], [448, 313, 8, 67], [356, 307, 92, 8], [355, 307, 8, 73], [300, 269, 81, 8], [426, 268, 67, 8], [355, 231, 137, 8], [355, 177, 8, 54], [358, 174, 133, 8], [296, 134, 110, 8], [444, 42, 8, 73], [404, 47, 8, 62], [362, 44, 8, 67], [330, 45, 8, 58]],
                enemyLocations: [[327, 157, 15, 1, "NORMAL"], [230, 290, 15, 1, "NORMAL"], [480, 480, 100, 0.2, 'FLOATER']],
                foodLocations: [[26, 164, 1], [64, 163, 1], [21, 207, 1], [64, 210, 1], [22, 251, 1], [68, 253, 1], [22, 301, 1], [69, 307, 1], [17, 347, 1], [72, 346, 1], [17, 384, 1], [17, 423, 1], [17, 468, 1], [78, 379, 1], [110, 383, 1], [130, 344, 1], [134, 303, 1], [150, 250, 1], [156, 210, 1], [176, 158, 1], [206, 173, 1], [224, 245, 1], [237, 294, 1], [253, 355, 1], [264, 387, 1], [54, 423, 1], [52, 462, 1], [88, 461, 1], [119, 456, 1], [148, 463, 1], [170, 457, 1], [224, 455, 1], [256, 456, 1], [301, 457, 1], [347, 451, 1], [385, 455, 1], [436, 443, 1], [462, 416, 1], [467, 363, 1], [466, 318, 1], [463, 287, 1], [399, 284, 1], [320, 281, 1], [321, 331, 1], [313, 384, 1], [389, 392, 1], [455, 244, 1], [318, 241, 1], [359, 244, 1], [399, 247, 1], [314, 198, 1], [317, 165, 1], [366, 146, 1], [416, 146, 1], [459, 146, 1], [465, 81, 1], [466, 43, 1], [377, 88, 1], [377, 53, 1], [306, 83, 1], [305, 45, 1], [341, 67, 2], [420, 67, 2], [263, 106, 1], [232, 107, 1], [202, 101, 1], [181, 101, 1], [170, 63, 1], [197, 59, 1], [218, 59, 1], [250, 62, 1], [268, 36, 1], [234, 25, 1], [206, 25, 1], [168, 25, 1], [185, 13, 1], [185, 76, 1], [186, 38, 1], [224, 80, 1], [241, 43, 1], [253, 22, 1], [219, 40, 1], [218, 10, 1], [246, 84, 1], [202, 81, 1], [162, 78, 1], [161, 42, 1], [166, 119, 1], [187, 118, 1], [214, 117, 1], [246, 117, 1], [269, 83, 1], [269, 60, 1], [272, 15, 1], [272, 120, 1], [270, 153, 1], [268, 194, 1], [267, 223, 1], [268, 257, 1], [270, 291, 1], [271, 336, 1], [273, 316, 1], [274, 364, 1], [234, 61, 5]],
                moneyItems: [{ "x": 100, "y": 392, "value": 20, "delayFromStartToShow": 5000, "delayFromStartToDie": 35000 }, { "x": 361, "y": 457, "value": 20, "delayFromStartToShow": 15000, "delayFromStartToDie": 45000 }, { "x": 321, "y": 314, "value": 20, "delayFromStartToShow": 25000, "delayFromStartToDie": 55000 }, { "x": 230, "y": 199, "value": 20, "delayFromStartToShow": 35000, "delayFromStartToDie": 65000 }, { "x": 194, "y": 50, "value": 20, "delayFromStartToShow": 45000, "delayFromStartToDie": 75000 }, { "x": 383, "y": 23, "value": 20, "delayFromStartToShow": 55000, "delayFromStartToDie": 85000 }],
                warpLocations: [{ "x": 183, "y": 457, "exit": { "x": 252, "y": 455 } }, { "x": 209, "y": 457, "exit": { "x": 139, "y": 455 } }],
                testMode: {
                    foodLocations: [[26, 164, 1]]
                }
            },

            2: {
                "playerStartLocation": { "x": 84, "y": 105 },
                "obstacles": [[430, 488, 2, 8], [428, 267, 8, 222], [428, 266, 66, 8], [427, 220, 67, 8], [427, 8, 8, 219], [65, 270, 8, 219], [7, 267, 68, 8], [6, 214, 61, 8], [64, 95, 8, 118], [71, 440, 161, 8], [229, 440, 8, 54], [275, 438, 8, 55], [275, 438, 157, 8], [153, 40, 84, 8], [229, 9, 8, 31], [275, 8, 8, 33], [275, 39, 150, 8], [119, 389, 263, 8], [375, 77, 8, 272], [200, 77, 175, 8], [196, 81, 8, 52], [116, 129, 80, 8], [116, 129, 8, 223], [153, 342, 190, 8], [153, 310, 8, 32], [153, 310, 182, 8], [335, 310, 8, 36], [121, 265, 103, 8], [260, 265, 75, 8], [331, 158, 8, 106], [262, 158, 69, 8], [259, 158, 8, 108], [164, 224, 94, 8], [167, 160, 8, 35], [167, 190, 59, 8], [218, 160, 8, 32], [167, 160, 51, 8], [235, 126, 55, 8], [307, 100, 66, 8], [306, 82, 8, 21]],
                "enemyLocations": [[238, 48, 20, 1.4, "NORMAL"], [390, 158, 20, 1.4, "NORMAL"], [230, 276, 120, 0.2, "FLOATER"]],
                "foodLocations": [[244, 411, 1], [92, 410, 2], [124, 409, 2], [156, 409, 2], [187, 407, 2], [215, 405, 2], [280, 406, 2], [309, 405, 2], [341, 406, 2], [381, 406, 2], [402, 405, 2], [152, 362, 1], [152, 362, 1], [182, 359, 1], [208, 359, 1], [234, 360, 1], [258, 361, 1], [286, 361, 1], [312, 360, 1], [325, 359, 1], [156, 282, 5], [180, 282, 5], [201, 282, 5], [228, 282, 5], [277, 288, 5], [252, 285, 5], [304, 285, 5], [323, 284, 5], [207, 241, 2], [182, 241, 2], [155, 241, 2], [133, 241, 2], [169, 203, 1], [190, 203, 1], [215, 200, 1], [235, 201, 1], [169, 140, 2], [198, 139, 2], [231, 95, 5], [271, 95, 5], [266, 138, 1], [291, 137, 1], [317, 136, 1], [349, 244, 8], [348, 209, 8], [346, 171, 8], [86, 325, 1], [86, 291, 1], [86, 253, 1], [83, 212, 1], [82, 174, 1], [84, 140, 1], [83, 106, 1], [397, 330, 1], [397, 299, 1], [395, 259, 1], [395, 211, 1], [395, 180, 1], [394, 138, 1], [394, 97, 1], [393, 56, 1], [360, 54, 1], [323, 52, 1], [289, 51, 1], [248, 52, 1], [214, 53, 1], [173, 54, 1], [170, 84, 1], [168, 107, 1], [131, 108, 1], [102, 105, 1], [82, 361, 1], [395, 328, 1], [393, 373, 1], [353, 357, 1], [113, 359, 1]],
                "moneyItems": [{ "x": 150, "y": 107, "value": 20, "delayFromStartToShow": 5000, "delayFromStartToDie": 35000 }, { "x": 301, "y": 54, "value": 20, "delayFromStartToShow": 15000, "delayFromStartToDie": 45000 }, { "x": 231, "y": 172, "value": 20, "delayFromStartToShow": 25000, "delayFromStartToDie": 55000 }, { "x": 350, "y": 373, "value": 20, "delayFromStartToShow": 35000, "delayFromStartToDie": 65000 }, { "x": 251, "y": 426, "value": 20, "delayFromStartToShow": 45000, "delayFromStartToDie": 75000 }, { "x": 90, "y": 308, "value": 20, "delayFromStartToShow": 55000, "delayFromStartToDie": 85000 }, { "x": 400, "y": 233, "value": 20, "delayFromStartToShow": 65000, "delayFromStartToDie": 95000 }],
                "warpLocations": [{ "x": 488, "y": 243, "exit": { "type": "WARP", "size": 5, "w": 5, "h": 5, "color": "#f00", "x": 48, "y": 242, "exit": null } }, { "x": 8, "y": 243, "exit": { "type": "WARP", "size": 5, "w": 5, "h": 5, "color": "#f00", "x": 445, "y": 243, "exit": null } }, { "x": 255, "y": 486, "exit": { "type": "WARP", "size": 5, "w": 5, "h": 5, "color": "#f00", "x": 255, "y": 34, "exit": null } }, { "x": 255, "y": 12, "exit": { "type": "WARP", "size": 5, "w": 5, "h": 5, "color": "#f00", "x": 255, "y": 455, "exit": null } }],
                testMode: {
                    foodLocations: [[120, 120, 1]]
                }
            },

            3: {
                playerStartLocation: { x: 13, y: 100 },
                obstacles: [[33, 409, 8, 49], [34, 456, 48, 8], [5, 367, 111, 8], [39, 408, 43, 8], [79, 410, 8, 47], [115, 413, 8, 78], [48, 329, 63, 8], [48, 256, 8, 73], [51, 252, 53, 8], [47, 217, 54, 8], [44, 128, 8, 85], [44, 127, 54, 8], [47, 211, 8, 10], [141, 130, 8, 239], [103, 256, 8, 76], [95, 127, 8, 91], [150, 414, 8, 75], [156, 414, 145, 8], [187, 448, 155, 8], [337, 355, 8, 91], [377, 354, 8, 96], [381, 445, 69, 8], [417, 409, 28, 8], [445, 278, 8, 133], [411, 278, 37, 8], [411, 298, 8, 111], [415, 281, 8, 22], [300, 318, 82, 8], [300, 319, 8, 62], [244, 371, 54, 8], [140, 368, 64, 8], [183, 329, 85, 8], [182, 233, 8, 94], [183, 231, 82, 8], [214, 293, 28, 8], [214, 268, 8, 27], [214, 267, 24, 8], [235, 267, 8, 27], [265, 270, 8, 24], [269, 290, 109, 8], [412, 246, 36, 8], [446, 99, 8, 148], [412, 99, 34, 8], [410, 99, 8, 145], [371, 102, 8, 188], [370, 53, 124, 8], [264, 228, 41, 8], [305, 228, 8, 32], [312, 257, 25, 8], [187, 189, 182, 8], [186, 49, 8, 140], [186, 47, 146, 8], [332, 49, 8, 139]],
                enemyLocations: [[275, 308, 20, 1.5, "NORMAL"], [430, 12, 20, 1.5, "NORMAL"], [480, 480, 140, 0.3, 'FLOATER']],
                foodLocations: [[15, 387, 2], [15, 414, 2], [15, 440, 2], [16, 468, 2], [39, 470, 3], [67, 470, 3], [95, 470, 2], [95, 443, 2], [95, 414, 2], [95, 387, 2], [43, 386, 2], [71, 386, 2], [131, 469, 2], [133, 444, 2], [132, 419, 2], [96, 348, 2], [70, 347, 2], [46, 344, 2], [23, 344, 2], [21, 315, 2], [21, 286, 2], [21, 257, 2], [20, 207, 2], [20, 183, 2], [21, 154, 2], [21, 127, 2], [22, 105, 3], [46, 107, 2], [70, 106, 2], [94, 106, 2], [122, 323, 2], [125, 301, 2], [125, 278, 2], [123, 259, 2], [121, 207, 2], [118, 187, 2], [117, 160, 2], [118, 132, 2], [118, 106, 2], [59, 232, 2], [82, 232, 2], [188, 346, 2], [160, 344, 2], [159, 310, 2], [158, 276, 2], [158, 239, 2], [158, 207, 2], [159, 169, 2], [159, 139, 2], [159, 108, 2], [165, 77, 3], [167, 47, 3], [167, 21, 3], [190, 21, 3], [214, 22, 3], [239, 20, 3], [264, 21, 3], [290, 21, 2], [321, 21, 2], [375, 24, 2], [403, 23, 2], [436, 23, 2], [471, 20, 2], [352, 166, 2], [353, 130, 2], [353, 102, 4], [353, 72, 2], [353, 44, 2], [351, 26, 2], [427, 76, 2], [425, 259, 2], [426, 424, 2], [469, 423, 2], [468, 390, 2], [468, 360, 2], [467, 332, 2], [466, 299, 2], [465, 274, 2], [465, 249, 2], [464, 223, 2], [464, 195, 2], [465, 170, 2], [463, 145, 2], [465, 123, 2], [465, 103, 2], [465, 78, 2], [392, 78, 2], [392, 108, 2], [390, 139, 2], [390, 171, 2], [390, 207, 2], [390, 237, 4], [390, 282, 4], [392, 316, 4], [391, 360, 4], [393, 390, 4], [394, 420, 4], [472, 450, 4], [467, 472, 4], [436, 471, 4], [405, 471, 4], [381, 471, 4], [326, 470, 4], [295, 470, 4], [260, 470, 2], [226, 470, 2], [195, 471, 2], [171, 471, 2], [168, 447, 2], [169, 428, 2], [198, 427, 2], [227, 428, 2], [260, 429, 2], [294, 431, 2], [319, 431, 2], [319, 374, 2], [320, 348, 2], [360, 338, 2], [358, 370, 2], [358, 396, 3], [357, 426, 3], [357, 451, 3], [357, 472, 3], [133, 388, 2], [166, 388, 2], [199, 388, 2], [244, 389, 2], [281, 390, 2], [248, 345, 2], [276, 345, 2], [197, 307, 3], [197, 282, 3], [195, 257, 3], [224, 249, 3], [228, 313, 3], [250, 308, 3], [248, 275, 3], [250, 253, 3], [280, 253, 3], [279, 271, 2], [303, 272, 2], [348, 272, 2], [323, 272, 2], [350, 246, 2], [349, 222, 2], [323, 239, 2], [324, 223, 2], [293, 206, 2], [253, 205, 2], [216, 205, 2], [189, 208, 2], [225, 355, 2], [224, 391, 2]],
                moneyItems: [{ "x": 220, "y": 82, "value": 20, "delayFromStartToShow": 5000, "delayFromStartToDie": 35000 }, { "x": 130, "y": 392, "value": 20, "delayFromStartToShow": 15000, "delayFromStartToDie": 45000 }, { "x": 282, "y": 82, "value": 20, "delayFromStartToShow": 25000, "delayFromStartToDie": 55000 }, { "x": 400, "y": 421, "value": 20, "delayFromStartToShow": 35000, "delayFromStartToDie": 65000 }, { "x": 224, "y": 147, "value": 20, "delayFromStartToShow": 45000, "delayFromStartToDie": 75000 }, { "x": 118, "y": 234, "value": 20, "delayFromStartToShow": 55000, "delayFromStartToDie": 85000 }],
                warpLocations: [{ "x": 357, "y": 473, "exit": { "x": 307, "y": 166 } }, { "x": 199, "y": 61, "exit": { "x": 19, "y": 344 } }],
                testMode: {
                    foodLocations: [[150, 387, 1]]
                }
            },
            4: {
                playerStartLocation: { x: 40, y: 100 },
                obstacles: [[7, 147, 199, 8], [204, 11, 8, 136], [206, 152, 8, 126], [206, 277, 109, 8], [315, 277, 8, 78], [318, 355, 99, 8], [417, 361, 8, 84], [417, 445, 54, 8], [471, 451, 8, 30], [471, 480, 8, 10], [7, 185, 157, 8], [165, 228, 8, 229], [38, 226, 128, 8], [38, 269, 92, 8], [38, 275, 8, 104], [7, 409, 91, 8], [110, 277, 8, 99], [44, 370, 67, 8], [41, 451, 124, 8], [208, 325, 48, 8], [208, 332, 8, 47], [208, 368, 46, 8], [244, 331, 8, 36], [250, 348, 31, 8], [273, 385, 8, 47], [309, 407, 47, 8], [333, 432, 8, 31], [210, 407, 34, 8], [228, 420, 8, 47], [273, 459, 22, 8], [385, 429, 8, 32], [452, 405, 40, 8], [422, 373, 8, 32], [424, 359, 39, 8], [406, 320, 54, 8], [406, 250, 8, 68], [411, 249, 44, 8], [451, 247, 8, 74], [372, 250, 8, 73], [348, 312, 25, 8], [346, 248, 27, 8], [348, 249, 8, 64], [248, 238, 68, 8], [211, 202, 62, 8], [303, 40, 8, 198], [242, 171, 61, 8], [211, 131, 56, 8], [245, 86, 56, 8], [211, 48, 47, 8], [445, 207, 8, 8], [350, 205, 94, 8], [367, 82, 8, 87], [426, 77, 8, 85], [346, 33, 109, 8]],
                enemyLocations: [[384, 88, 20, 1.5, "NORMAL"], [287, 425, 160, 0.5, enemyType.FLOATER]],
                foodLocations: [[21, 160, 2], [42, 156, 2], [71, 159, 2], [101, 160, 2], [129, 160, 2], [160, 160, 2], [183, 160, 2], [17, 201, 3], [36, 199, 3], [57, 199, 3], [85, 201, 3], [106, 200, 3], [131, 200, 3], [154, 200, 3], [182, 199, 3], [15, 245, 4], [142, 244, 4], [37, 241, 1], [63, 241, 1], [91, 241, 1], [116, 241, 1], [13, 276, 2], [15, 304, 2], [13, 330, 2], [13, 355, 2], [12, 382, 2], [41, 384, 2], [67, 384, 2], [99, 384, 2], [127, 383, 2], [136, 353, 2], [136, 326, 2], [135, 296, 2], [139, 267, 2], [143, 409, 3], [112, 410, 3], [124, 423, 4], [82, 421, 2], [51, 422, 2], [19, 420, 2], [17, 447, 3], [16, 474, 3], [53, 471, 3], [86, 471, 3], [116, 470, 3], [150, 469, 3], [185, 469, 3], [183, 428, 3], [180, 373, 3], [178, 326, 3], [177, 277, 3], [179, 235, 3], [220, 294, 3], [244, 292, 3], [268, 293, 3], [292, 292, 3], [265, 319, 3], [292, 320, 3], [257, 362, 5], [314, 417, 5], [217, 385, 3], [207, 432, 3], [244, 429, 3], [251, 383, 3], [290, 357, 3], [289, 387, 3], [289, 418, 3], [355, 439, 3], [305, 450, 3], [241, 465, 3], [349, 465, 3], [397, 466, 3], [397, 421, 3], [393, 378, 3], [363, 399, 3], [360, 373, 3], [326, 379, 3], [423, 460, 5], [455, 416, 5], [431, 414, 3], [435, 380, 3], [460, 379, 3], [471, 336, 3], [435, 333, 3], [389, 330, 3], [346, 330, 3], [325, 296, 3], [323, 258, 3], [279, 253, 3], [240, 252, 3], [221, 222, 3], [261, 215, 3], [283, 190, 3], [246, 180, 3], [219, 178, 3], [218, 139, 3], [242, 153, 3], [240, 140, 3], [252, 154, 3], [252, 139, 3], [262, 152, 3], [264, 135, 3], [274, 152, 3], [276, 135, 3], [285, 109, 3], [250, 101, 3], [220, 101, 3], [218, 64, 3], [250, 61, 3], [278, 60, 3], [276, 25, 3], [219, 17, 5], [244, 20, 4], [317, 16, 3], [358, 11, 1], [389, 6, 1], [412, 12, 1], [446, 11, 1], [469, 12, 1], [321, 48, 3], [321, 81, 3], [321, 107, 3], [315, 146, 3], [319, 175, 3], [319, 208, 3], [352, 221, 3], [386, 222, 2], [426, 217, 2], [462, 219, 2], [467, 257, 2], [470, 294, 2], [358, 179, 2], [388, 179, 2], [428, 174, 2], [459, 174, 2], [392, 142, 3], [389, 112, 3], [392, 82, 3], [455, 139, 2], [453, 96, 2], [456, 54, 2], [362, 48, 5], [415, 46, 5]],
                moneyItems: [{ "x": 135, "y": 312, "value": 20, "delayFromStartToShow": 5000, "delayFromStartToDie": 35000 }, { "x": 285, "y": 311, "value": 20, "delayFromStartToShow": 15000, "delayFromStartToDie": 45000 }, { "x": 392, "y": 226, "value": 20, "delayFromStartToShow": 25000, "delayFromStartToDie": 55000 }, { "x": 272, "y": 102, "value": 20, "delayFromStartToShow": 35000, "delayFromStartToDie": 65000 }, { "x": 26, "y": 427, "value": 20, "delayFromStartToShow": 45000, "delayFromStartToDie": 75000 }, { "x": 360, "y": 466, "value": 20, "delayFromStartToShow": 55000, "delayFromStartToDie": 85000 }, { "x": 189, "y": 128, "value": 20, "delayFromStartToShow": 65000, "delayFromStartToDie": 95000 }],
                warpLocations: [{ "x": 14, "y": 159, "exit": { "x": 18, "y": 109 } }, { "x": 170, "y": 137, "exit": { "x": 449, "y": 470 } }, { "x": 196, "y": 109, "exit": { "x": 480, "y": 425 } }, { "x": 396, "y": 60, "exit": { "x": 163, "y": 13 } }],
                testMode: {
                    enemyLocations: [[384, 88, 20, 2, "NORMAL"]],
                    foodLocations: [[21, 160, 2]],
                }
            },
            5: {
                playerStartLocation: { x: 225, y: 197 },
                obstacles: [[136, 228, 215, 8], [138, 279, 211, 8], [81, 149, 8, 215], [7, 244, 39, 8], [42, 100, 8, 100], [42, 298, 8, 135], [49, 427, 308, 8], [170, 323, 8, 57], [213, 323, 8, 52], [257, 320, 8, 55], [310, 322, 8, 56], [126, 322, 8, 49], [136, 180, 210, 8], [155, 35, 125, 8], [331, 8, 8, 74], [197, 80, 134, 8], [141, 134, 196, 8], [349, 323, 8, 50], [371, 34, 8, 68], [374, 34, 81, 8], [452, 40, 8, 58], [374, 94, 78, 8], [391, 140, 8, 226], [395, 140, 59, 8], [442, 140, 8, 225], [395, 355, 47, 8], [390, 408, 8, 52], [391, 456, 65, 8], [451, 406, 8, 50], [391, 406, 60, 8], [125, 369, 8, 13], [81, 363, 8, 16]],
                enemyLocations: [[95, 194, 8, 3.5, enemyType.SPEEDY], [358, 194, 7, 3.5, enemyType.SPEEDY], [226, 391, 95, 0.8, enemyType.TANK], [224, 46, 100, 0.9, enemyType.TANK], [409, 108, 115, 1, enemyType.TANK], [407, 368, 150, 0.85, enemyType.TANK], [14, 209, 85, 0.95, enemyType.TANK], [11, 264, 180, 0.5, enemyType.FLOATER], [92, 454, 100, 0.7, enemyType.TANK]],
                foodLocations: [[139, 200, 4], [166, 196, 4], [198, 196, 4], [267, 198, 4], [305, 197, 4], [337, 195, 4], [138, 251, 4], [168, 249, 4], [197, 249, 4], [230, 251, 4], [264, 249, 4], [297, 249, 4], [335, 249, 4], [136, 155, 4], [162, 156, 4], [192, 155, 4], [216, 153, 4], [247, 151, 4], [282, 151, 4], [321, 153, 4], [144, 343, 5], [187, 342, 5], [233, 341, 5], [281, 340, 5], [330, 341, 5], [14, 117, 6], [184, 11, 6], [17, 269, 4], [16, 300, 4], [12, 341, 4], [16, 380, 4], [16, 420, 4], [17, 454, 4], [54, 454, 4], [103, 457, 4], [142, 454, 4], [192, 453, 4], [228, 456, 4], [284, 449, 4], [334, 452, 4], [366, 454, 4], [365, 454, 4], [390, 459, 4], [411, 472, 4], [446, 472, 4], [472, 471, 4], [471, 430, 4], [468, 378, 4], [431, 374, 4], [388, 375, 4], [367, 414, 4], [367, 374, 4], [323, 399, 4], [274, 399, 4], [210, 399, 4], [140, 393, 4], [98, 395, 4], [58, 397, 4], [56, 356, 4], [56, 318, 4], [55, 278, 4], [55, 247, 4], [57, 211, 4], [20, 211, 4], [17, 179, 4], [58, 177, 4], [17, 145, 4], [62, 138, 4], [62, 111, 4], [368, 335, 4], [364, 291, 4], [365, 254, 4], [365, 200, 4], [363, 161, 4], [363, 118, 4], [391, 119, 4], [425, 118, 5], [465, 116, 5], [470, 174, 5], [470, 233, 5], [469, 279, 5], [469, 333, 5], [470, 77, 5], [467, 35, 5], [427, 16, 5], [375, 14, 5], [346, 19, 5], [347, 59, 5], [332, 103, 5], [287, 101, 5], [232, 100, 5], [181, 98, 5], [175, 57, 5], [221, 57, 5], [274, 57, 5], [308, 52, 5], [304, 14, 5], [270, 14, 5], [224, 11, 5], [104, 110, 5], [110, 155, 5], [99, 213, 5], [106, 249, 5], [105, 281, 5], [102, 324, 5], [174, 393, 5]],
                moneyItems: [{ "x": 110, "y": 151, "value": 20, "delayFromStartToShow": 5000, "delayFromStartToDie": 35000 }, { "x": 475, "y": 57, "value": 20, "delayFromStartToShow": 15000, "delayFromStartToDie": 45000 }, { "x": 292, "y": 50, "value": 20, "delayFromStartToShow": 25000, "delayFromStartToDie": 55000 }, { "x": 58, "y": 240, "value": 20, "delayFromStartToShow": 35000, "delayFromStartToDie": 65000 }, { "x": 60, "y": 404, "value": 20, "delayFromStartToShow": 45000, "delayFromStartToDie": 75000 }, { "x": 294, "y": 456, "value": 20, "delayFromStartToShow": 55000, "delayFromStartToDie": 85000 }, { "x": 468, "y": 375, "value": 20, "delayFromStartToShow": 65000, "delayFromStartToDie": 95000 }, { "x": 325, "y": 202, "value": 20, "delayFromStartToShow": 75000, "delayFromStartToDie": 105000 }],
                warpLocations: [{ "x": 21, "y": 105, "exit": { "x": 221, "y": 18 } }, { "x": 163, "y": 14, "exit": { "x": 21, "y": 146 } }],
                testMode: {
                    enemyLocations: [[226, 391, 95, 1.3, enemyType.TANK]],
                    foodLocations: [[139, 200, 3]],
                }
            },
            6: {
                "playerStartLocation": { x: 70, y: 130 },
                "obstacles": [[40, 117, 8, 76], [42, 187, 82, 8], [117, 117, 8, 70], [40, 116, 77, 8], [44, 248, 8, 0], [44, 248, 8, 70], [45, 316, 75, 8], [113, 244, 8, 72], [43, 243, 70, 8], [43, 386, 8, 65], [43, 447, 79, 8], [115, 382, 8, 65], [41, 380, 74, 8], [169, 383, 8, 66], [169, 445, 70, 8], [237, 378, 8, 67], [173, 375, 64, 8], [175, 241, 8, 81], [175, 320, 75, 8], [242, 243, 8, 77], [180, 237, 62, 8], [174, 117, 8, 75], [174, 189, 65, 8], [234, 114, 8, 75], [178, 112, 56, 8], [179, 21, 8, 50], [180, 71, 279, 8], [453, 18, 8, 58], [179, 17, 274, 8], [301, 245, 8, 79], [301, 321, 88, 8], [386, 243, 8, 78], [302, 239, 84, 8], [275, 97, 8, 41], [275, 138, 180, 8], [453, 94, 8, 46], [278, 94, 175, 8], [277, 167, 8, 42], [277, 209, 183, 8], [456, 163, 8, 46], [279, 163, 177, 8], [305, 379, 8, 76], [306, 450, 90, 8], [391, 374, 8, 76], [307, 372, 84, 8]], "enemyLocations": [[300, 250, 200, 0.6, "FLOATER"], [444, 357, 50, 1.8, "NORMAL"], [126, 335, 20, 2.2, "NORMAL"], [242, 88, 90, 1.4, "NORMAL"]],
                "foodLocations": [[396, 161, 1], [378, 240, 1], [446, 261, 1], [440, 261, 1], [368, 427, 1], [326, 427, 1], [325, 393, 1], [356, 394, 1], [189, 422, 5], [215, 421, 5], [214, 395, 5], [188, 391, 5], [91, 421, 6], [58, 420, 6], [57, 401, 6], [81, 399, 6], [56, 291, 5], [84, 289, 5], [81, 265, 5], [55, 266, 5], [54, 155, 3], [75, 152, 3], [95, 152, 3], [95, 130, 3], [188, 129, 4], [210, 130, 4], [186, 148, 4], [209, 148, 4], [204, 264, 8], [203, 284, 8], [234, 34, 9], [281, 36, 9], [340, 31, 9], [388, 32, 9], [308, 112, 3], [350, 111, 3], [388, 111, 3], [308, 183, 4], [344, 180, 4], [398, 181, 4], [417, 181, 4], [328, 278, 2], [356, 275, 2], [457, 311, 2], [446, 310, 2], [435, 310, 2], [433, 323, 2], [442, 323, 2], [456, 323, 2], [457, 336, 2], [442, 336, 2], [426, 336, 2], [431, 255, 1], [438, 250, 1], [448, 249, 1], [449, 254, 1], [450, 262, 1], [436, 271, 1], [431, 269, 1], [428, 262, 1], [447, 270, 1], [448, 384, 3], [438, 385, 3], [435, 402, 3], [442, 406, 3], [450, 406, 3], [451, 390, 3], [428, 452, 4], [427, 466, 4], [435, 467, 4], [439, 455, 4], [317, 469, 5], [330, 470, 5], [201, 465, 6], [77, 469, 7], [9, 400, 8], [15, 285, 9]],
                "moneyItems": [],
                "warpLocations": [{ "x": 79, "y": 176, "exit": { "x": 77, "y": 259 } }, { "x": 75, "y": 308, "exit": { "x": 75, "y": 394 } }, { "x": 111, "y": 416, "exit": { "x": 181, "y": 414 } }, { "x": 206, "y": 385, "exit": { "x": 209, "y": 309 } }, { "x": 207, "y": 252, "exit": { "x": 205, "y": 180 } }, { "x": 203, "y": 124, "exit": { "x": 205, "y": 46 } }, { "x": 107, "y": 284, "exit": { "x": 186, "y": 280 } }, { "x": 236, "y": 280, "exit": { "x": 315, "y": 279 } }, { "x": 435, "y": 43, "exit": { "x": 437, "y": 116 } }, { "x": 290, "y": 118, "exit": { "x": 291, "y": 189 } }, { "x": 375, "y": 189, "exit": { "x": 370, "y": 257 } }, { "x": 342, "y": 312, "exit": { "x": 342, "y": 395 } }, { "x": 379, "y": 418, "exit": { "x": 407, "y": 420 } }, { "x": 444, "y": 226, "exit": { "x": 445, "y": 193 } }, { "x": 31, "y": 138, "exit": { "x": 71, "y": 140 } }],
                testMode: {
                    foodLocations: [[80, 150, 2]]
                }
            },
            7: {
                playerStartLocation: { "x": 14, "y": 115 },
                obstacles: [[52, 100, 8, 349], [52, 448, 394, 8], [446, 43, 8, 405], [197, 43, 249, 8], [156, 80, 247, 8], [401, 88, 8, 315], [99, 403, 302, 8], [99, 135, 8, 269], [101, 135, 257, 8], [357, 137, 8, 228], [148, 354, 209, 8], [143, 179, 8, 175], [143, 179, 170, 8], [312, 181, 8, 132], [192, 306, 120, 8], [192, 223, 8, 83], [193, 222, 86, 8], [276, 222, 8, 53], [237, 271, 39, 8], [237, 252, 8, 19]],
                enemyLocations: [
                    //horizontal
                    [463, 50, 81, 1.4, "PATTERNCHASER", [{ x: 2, y: 12 }, { x: 470, y: 57 }, { x: 470, y: 12 }]],
                    [420, 100, 82, 1.4, "PATTERNCHASER", [{ x: 2, y: 57 }, { x: 470, y: 107 }, { x: 470, y: 57 }]],
                    [340, 200, 84, 1.4, "PATTERNCHASER", [{ x: 2, y: 197 }, { x: 470, y: 247 }, { x: 470, y: 197 }]],
                    [300, 250, 85, 1.4, "PATTERNCHASER", [{ x: 2, y: 247 }, { x: 470, y: 280 }, { x: 470, y: 247 }]],
                    [220, 350, 87, 1.4, "PATTERNCHASER", [{ x: 2, y: 327 }, { x: 470, y: 363 }, { x: 470, y: 327 }]],
                    [180, 400, 88, 1.4, "PATTERNCHASER", [{ x: 2, y: 376 }, { x: 470, y: 428 }, { x: 470, y: 376 }]],
                    [140, 450, 89, 1.4, "PATTERNCHASER", [{ x: 2, y: 428 }, { x: 470, y: 463 }, { x: 470, y: 428 }]],
                    // vertical
                    [425, 450, 71, 1.4, "PATTERNCHASER", [{ x: 425, y: 2 }, { x: 375, y: 470 }, { x: 425, y: 470 }]],
                    [375, 400, 72, 1.4, "PATTERNCHASER", [{ x: 375, y: 2 }, { x: 326, y: 470 }, { x: 375, y: 470 }]],
                    [326, 350, 73, 1.4, "PATTERNCHASER", [{ x: 326, y: 2 }, { x: 292, y: 470 }, { x: 326, y: 470 }]],
                    [292, 300, 74, 1.4, "PATTERNCHASER", [{ x: 292, y: 2 }, { x: 246, y: 470 }, { x: 292, y: 470 }]],
                    [205, 200, 76, 1.4, "PATTERNCHASER", [{ x: 205, y: 2 }, { x: 156, y: 470 }, { x: 205, y: 470 }]],
                    [156, 150, 77, 1.4, "PATTERNCHASER", [{ x: 156, y: 2 }, { x: 113, y: 470 }, { x: 156, y: 470 }]],
                    [113, 100, 78, 1.4, "PATTERNCHASER", [{ x: 113, y: 2 }, { x: 66, y: 470 }, { x: 113, y: 470 }]],
                ],
                foodLocations: [[20, 145, 1], [19, 173, 1], [18, 205, 1], [16, 231, 1], [16, 265, 1], [16, 293, 1], [12, 325, 1], [14, 349, 1], [14, 380, 1], [14, 408, 1], [14, 436, 1], [9, 465, 1], [33, 468, 2], [58, 469, 2], [82, 468, 2], [105, 466, 2], [127, 466, 2], [146, 466, 2], [171, 465, 2], [196, 465, 2], [220, 464, 2], [248, 464, 2], [274, 465, 2], [294, 463, 2], [320, 465, 2], [342, 463, 2], [364, 464, 2], [394, 466, 2], [410, 464, 2], [428, 464, 2], [452, 464, 2], [469, 466, 2], [464, 437, 3], [465, 404, 3], [464, 374, 3], [464, 340, 3], [462, 302, 3], [463, 254, 3], [462, 214, 3], [461, 181, 3], [461, 143, 3], [459, 96, 3], [459, 57, 3], [458, 25, 3], [422, 20, 4], [385, 19, 4], [351, 14, 4], [317, 13, 4], [267, 12, 4], [234, 12, 4], [201, 12, 4], [170, 12, 4], [170, 36, 4], [170, 55, 4], [204, 58, 4], [242, 52, 4], [276, 52, 4], [311, 53, 4], [347, 55, 4], [384, 55, 4], [412, 56, 4], [421, 83, 5], [421, 121, 5], [421, 150, 5], [418, 184, 5], [417, 220, 5], [416, 251, 5], [419, 293, 5], [418, 323, 5], [418, 355, 5], [418, 385, 5], [418, 421, 5], [388, 425, 6], [352, 426, 6], [319, 425, 6], [274, 425, 6], [229, 424, 6], [191, 421, 6], [157, 421, 6], [108, 421, 6], [78, 421, 6], [131, 420, 6], [74, 391, 7], [72, 361, 7], [72, 333, 7], [71, 298, 7], [71, 259, 7], [70, 229, 7], [66, 199, 7], [69, 163, 7], [69, 132, 7], [70, 99, 7], [101, 102, 8], [126, 103, 8], [147, 102, 8], [170, 102, 8], [202, 102, 8], [236, 102, 8], [259, 102, 8], [284, 102, 8], [312, 102, 8], [339, 103, 8], [369, 104, 8], [372, 135, 9], [372, 165, 9], [372, 186, 9], [374, 206, 9], [372, 233, 9], [370, 262, 9], [369, 289, 9], [369, 316, 9], [369, 348, 9], [369, 369, 9], [334, 374, 8], [293, 372, 8], [264, 373, 8], [228, 373, 8], [191, 373, 8], [154, 374, 8], [113, 374, 8], [116, 338, 7], [117, 296, 7], [116, 264, 7], [116, 227, 7], [115, 199, 7], [118, 153, 7], [150, 153, 6], [189, 150, 6], [221, 151, 6], [259, 153, 6], [299, 155, 6], [334, 154, 6], [334, 190, 5], [334, 224, 5], [334, 257, 5], [333, 289, 5], [332, 320, 5], [300, 325, 4], [272, 327, 4], [247, 326, 4], [208, 326, 4], [182, 324, 4], [157, 324, 4], [162, 292, 3], [160, 258, 3], [161, 225, 3], [159, 197, 3], [187, 194, 2], [210, 196, 2], [232, 196, 2], [259, 194, 2], [289, 194, 2], [292, 229, 1], [291, 260, 1], [290, 281, 1], [268, 281, 9], [237, 284, 9], [216, 283, 9], [211, 253, 9], [254, 251, 9], [228, 234, 9]],
                "moneyItems": [{ "x": 254, "y": 462, "value": 20, "delayFromStartToShow": 75000, "delayFromStartToDie": 105000 }, { "x": 327, "y": 374, "value": 20, "delayFromStartToShow": 85000, "delayFromStartToDie": 115000 }, { "x": 251, "y": 283, "value": 20, "delayFromStartToShow": 95000, "delayFromStartToDie": 125000 }, { "x": 172, "y": 332, "value": 20, "delayFromStartToShow": 105000, "delayFromStartToDie": 135000 }, { "x": 374, "y": 101, "value": 20, "delayFromStartToShow": 115000, "delayFromStartToDie": 145000 }, { "x": 333, "y": 17, "value": 20, "delayFromStartToShow": 125000, "delayFromStartToDie": 155000 }, { "x": 76, "y": 288, "value": 20, "delayFromStartToShow": 135000, "delayFromStartToDie": 165000 }],
                "warpLocations": []
            },

            8: {
                "playerStartLocation": { "x": 36, "y": 111 },
                "obstacles": [[197, 226, 8, 79], [198, 302, 98, 8], [296, 222, 8, 80], [246, 310, 8, 58], [305, 258, 75, 8], [119, 263, 78, 8], [360, 187, 8, 69], [131, 269, 8, 52], [343, 180, 94, 8], [155, 176, 8, 84], [70, 195, 84, 8], [82, 204, 8, 51], [97, 128, 8, 63], [25, 144, 69, 8], [41, 253, 48, 8], [60, 259, 8, 101], [234, 277, 8, 20], [226, 108, 8, 129], [175, 123, 50, 8], [185, 35, 8, 83], [191, 61, 67, 8], [223, 186, 8, 0], [197, 184, 29, 8], [260, 30, 8, 79], [269, 75, 83, 8], [268, 158, 53, 8], [277, 168, 8, 49], [277, 216, 27, 8], [406, 40, 8, 140], [459, 37, 8, 65], [373, 49, 35, 8], [375, 130, 29, 8], [423, 186, 8, 134], [429, 240, 35, 8], [346, 311, 77, 8], [289, 310, 8, 30], [294, 337, 30, 8], [322, 342, 8, 52], [332, 369, 98, 8], [381, 314, 8, 14], [395, 378, 8, 60], [352, 418, 39, 8], [354, 424, 8, 28], [400, 415, 59, 8], [434, 417, 8, 27], [269, 442, 87, 8], [288, 381, 8, 53], [197, 401, 88, 8], [210, 355, 8, 42], [111, 376, 99, 8], [145, 351, 8, 19], [138, 384, 8, 77], [150, 433, 32, 8], [231, 407, 8, 43], [52, 420, 84, 8], [75, 390, 8, 29], [37, 325, 24, 8], [73, 431, 8, 38], [312, 35, 8, 35], [38, 152, 8, 35], [413, 101, 47, 8], [445, 150, 8, 28], [431, 180, 19, 8], [331, 79, 8, 39], [203, 238, 51, 8], [108, 317, 65, 8]],
                "enemyLocations": [
                    [31, 462, 121, 5, "PATTERNCHASER", [
                        // top pattern in
                        { x: 7, y: 230 }, { x: 45, y: 230 }, { x: 45, y: 170 }, { x: 80, y: 170 },
                        // top pattern out
                        { x: 45, y: 170 }, { x: 45, y: 230 }, { x: 7, y: 230 }, { x: 7, y: 420 },
                        // bottom pattern in
                        { x: 80, y: 350 }, { x: 80, y: 280 }, { x: 100, y: 280 }, { x: 100, y: 210 }, { x: 130, y: 210 }, { x: 130, y: 230 },
                        // bottom pattern out
                        { x: 100, y: 230 }, { x: 100, y: 280 }, { x: 100, y: 280 }, { x: 80, y: 280 }, { x: 80, y: 350 }, { x: 7, y: 420 }
                    ]],
                    [470, 461, 111, 5.5, "PATTERNCHASER", [
                        // left pattern in    
                        { x: 200, y: 461 }, { x: 200, y: 414 }, { x: 160, y: 414 },
                        // left pattern out
                        { x: 200, y: 414 }, { x: 200, y: 461 }, { x: 470, y: 461 },
                        // top pattern in
                        { x: 470, y: 340 }, { x: 340, y: 340 }, { x: 320, y: 300 }, { x: 320, y: 270 }, { x: 380, y: 270 }, { x: 380, y: 190 },
                        // top pattern out
                        { x: 380, y: 270 }, { x: 320, y: 270 }, { x: 320, y: 320 }, { x: 390, y: 340 }, { x: 470, y: 340 }, { x: 470, y: 461 }
                    ]],
                    [322, 125, 101, 4, "PATTERNCHASER", [
                        // left pattern in    
                        { x: 237, y: 125 }, { x: 237, y: 210 },
                        // left pattern out
                        { x: 237, y: 125 }, { x: 322, y: 125 },
                        // bottom pattern in & out
                        { x: 322, y: 225 }, { x: 322, y: 125 }
                    ]],
                    [180, 7, 91, 6, 'PATTERNCHASER', [{ x: 470, y: 7 }, { x: 180, y: 7 }]],
                    [470, 200, 81, 7, 'PATTERNCHASER', [{ x: 470, y: 7 }, { x: 470, y: 385 }]]
                ],
                "foodLocations": [[166, 237, 1], [180, 235, 1], [209, 201, 1], [190, 200, 1], [165, 199, 1], [174, 216, 1], [338, 234, 2], [315, 234, 2], [340, 209, 2], [315, 207, 2], [291, 191, 2], [290, 169, 2], [209, 281, 3], [212, 251, 3], [248, 283, 3], [268, 279, 3], [243, 254, 3], [271, 255, 3], [431, 163, 4], [417, 163, 4], [431, 146, 4], [416, 143, 4], [375, 197, 5], [398, 194, 5], [371, 213, 5], [382, 215, 5], [401, 214, 5], [371, 236, 5], [387, 233, 5], [403, 233, 5], [175, 417, 6], [155, 414, 6], [176, 399, 6], [155, 395, 6], [166, 388, 6], [378, 400, 7], [376, 383, 7], [357, 401, 7], [355, 380, 7], [337, 381, 7], [337, 399, 7], [334, 422, 7], [309, 425, 7], [316, 404, 7], [301, 404, 7], [137, 241, 8], [120, 241, 8], [102, 241, 8], [138, 222, 8], [118, 222, 8], [99, 222, 8], [126, 207, 8], [102, 202, 8], [89, 243, 8], [80, 181, 9], [78, 160, 9], [67, 180, 9], [64, 163, 9], [52, 183, 9], [49, 156, 9], [51, 202, 9], [63, 206, 9], [51, 217, 9], [64, 221, 9], [47, 232, 9], [65, 238, 9], [282, 52, 9], [428, 81, 9], [406, 391, 9], [436, 211, 9], [259, 420, 9], [272, 419, 9], [99, 435, 9], [112, 395, 9], [150, 286, 9], [262, 315, 9], [302, 356, 9], [45, 287, 9], [44, 336, 9], [21, 153, 9], [79, 124, 9], [200, 97, 9], [314, 84, 9], [407, 295, 9], [299, 318, 9], [306, 269, 9], [331, 351, 9], [408, 425, 9], [374, 429, 9]],
                "moneyItems": [{ "x": 389, "y": 273, "value": 20, "delayFromStartToShow": 5000, "delayFromStartToDie": 35000 }, { "x": 180, "y": 203, "value": 20, "delayFromStartToShow": 15000, "delayFromStartToDie": 45000 }, { "x": 179, "y": 354, "value": 20, "delayFromStartToShow": 25000, "delayFromStartToDie": 55000 }, { "x": 51, "y": 216, "value": 20, "delayFromStartToShow": 35000, "delayFromStartToDie": 65000 }, { "x": 117, "y": 225, "value": 20, "delayFromStartToShow": 45000, "delayFromStartToDie": 75000 }, { "x": 367, "y": 395, "value": 20, "delayFromStartToShow": 55000, "delayFromStartToDie": 85000 }, { "x": 426, "y": 160, "value": 20, "delayFromStartToShow": 65000, "delayFromStartToDie": 95000 }],
                "warpLocations": []
            }
        }

        // random number generator
        function random(low, high, includeHigh) {
            var inclusiveIncrementer = includeHigh ? 1 : 0
            return Math.floor(Math.random() * (high - low + inclusiveIncrementer)) + low;
        }

        // checks if an entity is in the HUD area
        function hudCheck(entity, ignoreHudAreaWarning) {
            var rightSideOfHUD = hudWalls[1][0];
            var bottomOfHUD = hudWalls[1][3]
            if (!ignoreHudAreaWarning && entity.x < rightSideOfHUD && entity.y < bottomOfHUD) {
                console.warn('In the HUD area');
                console.log(entity);
            }
        }

        function removeFromArrayById(arr, id) {
            for (var i = arr.length - 1; i >= 0; i--) {
                if (arr[i].id === id) {
                    arr.splice(i, 1);
                    return;
                }
            }
        }

        // helper function to see if there's a wall where the enemy wants to move
        // I'm going to be lenient with a few pixels since the user gets the same consideration
        function areaContainsWall(x1, x2, y1, y2, pixelAllowance, wallsCache) {
            var xAllowance = 0;
            var yAllowance = 0;
            // whole numbers or bust
            if (x2 - x1 > 8) xAllowance = Math.floor(pixelAllowance);
            if (y2 - y1 > 8) yAllowance = Math.floor(pixelAllowance);
            x1 = Math.floor(x1);
            x2 = Math.floor(x2);
            y1 = Math.floor(y1);
            y2 = Math.floor(y2);
            for (var i = x1 + xAllowance; i <= x2 - xAllowance; i++) {
                for (var j = y1 + yAllowance; j <= y2 - yAllowance; j++) {
                    var point = i + '|' + j;
                    if (wallsCache[point]) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Player input
        var Input = {
            init: function (data) {
                this.setMovementKeys(data);
                this.setMenuKeys(data);
            },

            setMovementKeys: function (data) {
                data.eventListeners.handleKeyDown = function () {
                    // keeps arrow keys from scrolling the page
                    if (event.keyCode >= 37 && event.keyCode <= 40) {
                        event.preventDefault();
                    }
                    Input.helpers.down[event.keyCode] = true;
                }
                data.eventListeners.handleKeyUp = function () {
                    delete Input.helpers.down[event.keyCode];
                    delete Input.helpers.pressed[event.keyCode];
                }
                $(window).on('keydown', data.eventListeners.handleKeyDown);
                $(window).on('keyup', data.eventListeners.handleKeyUp)
            },

            // stops player movement
            allMovementKeysUp: function (data) {
                delete Input.helpers.down['37'];
                delete Input.helpers.pressed['37'];
                delete Input.helpers.down['38'];
                delete Input.helpers.pressed['38'];
                delete Input.helpers.down['39'];
                delete Input.helpers.pressed['39'];
                delete Input.helpers.down['40'];
                delete Input.helpers.pressed['40'];
            },

            setMenuKeys: function (data) {
                data.eventListeners.handleKeyPress = function () {
                    // space bar pauses game which opens menu
                    if (event.keyCode === 32) {
                        event.preventDefault();
                        Input.allMovementKeysUp(data);
                        data.gameRunning = !data.gameRunning;
                    }
                    // while menu is open, hotkeys trigger menu transactions
                    if (!data.gameRunning) {
                        Input.handleShopPurchases(data, event);
                    }
                }
                $(window).on('keypress', data.eventListeners.handleKeyPress);
            },

            handleShopPurchases(data, event) {
                // if the game is over, do nothing
                if (data.gameOver) return;

                // otherwise buy stuff
                var shopItem = data.shopItems[event.code];
                if (!shopItem) return;

                var player = data.entities.player;
                // costType could be money or points
                var playersBalanceOfCostType = player[shopItem.costType]
                // see if player can purchase
                if (playersBalanceOfCostType < shopItem.cost) {
                    return alert('You dont have enough ' + shopItem.costType + ' for that item. \nCost: ' + shopItem.cost + ' \nYou have ' + playersBalanceOfCostType)
                }

                // copy the item so we can change it without changing the store's items
                var changesToPlayer = JSON.parse(JSON.stringify(shopItem));

                // the cost type is either points/money so we change that attribute on the player
                // object by the cost amount * -1
                changesToPlayer[shopItem.costType] = changesToPlayer.cost * -1;
                delete changesToPlayer.cost;
                delete changesToPlayer.costType;
                delete changesToPlayer.costIncrease;

                // at this point the item represents the changes to the player object that need to happen
                for (var key in changesToPlayer) {
                    player[key] += changesToPlayer[key]
                }

                // update the item's cost if needed
                shopItem.cost = Math.floor(shopItem.cost * shopItem.costMultiplier)

                // each time something is purchased, redraw the menu
                Game.showMenu(data)
            },

            update: function (data) {
                var player = data.entities.player;
                var leftArrowDown = Input.helpers.isDown(37);
                var rightArrowDown = Input.helpers.isDown(39);
                var upArrowDown = Input.helpers.isDown(38);
                var downArrowDown = Input.helpers.isDown(40);

                player.direction = {
                    left: false,
                    up: false,
                    right: false,
                    down: false
                }

                if (leftArrowDown) {
                    player.x -= player.velX
                    player.direction.left = true;
                }

                if (rightArrowDown) {
                    player.x += player.velX;
                    player.direction.right = true;
                }

                if (upArrowDown) {
                    player.y -= player.velY;
                    player.direction.up = true;
                }

                if (downArrowDown) {
                    player.y += player.velY;
                    player.direction.down = true;
                }
            },

            helpers: {
                isDown: function (code) {
                    return Input.helpers.down[code];
                },

                isPressed: function (code) {
                    if (Input.helpers.pressed[code]) {
                        return false;
                    } else if (Input.helpers.down[code]) {
                        return Input.helpers.pressed[code] = true;
                    } else {
                        return false;
                    }
                },

                down: {},
                pressed: {},
            },
        }

        // Entities Script
        var Entities = {
            init: function (data) {
                var background = {
                    x: 0,
                    y: 0,
                    w: 1000,
                    h: 800,
                };

                var player = new Entities.helpers.player();

                data.entities = {
                    background: background,
                    player: player,
                    wallsArray: [],
                    enemiesArray: [],
                    foodArray: [],
                };

                // put the walls up
                var wallLocations = hudWalls.concat(edgeWalls);
                wallLocations.forEach(function (wall) {
                    var wallObj = new Entities.helpers.Wall(wall[0], wall[1], wall[2], wall[3], WALL);
                    var ignoreHudAreaWarning = wall[4];
                    hudCheck(wallObj, ignoreHudAreaWarning);
                    data.entities.wallsArray.push(wallObj)
                });
            },

            clearLevelSpecificEntities: function (data) {
                // remove all enemies and food
                data.entities.enemiesArray = [];
                data.entities.foodArray = [];
                data.entities.moneyArray = [];
                data.entities.warpArray = [];
                // remove obstacle walls, keep edge and HUD walls
                var newWallsArray = [];
                data.entities.wallsArray.forEach(function (wall) {
                    if (wall.wallType === WALL) newWallsArray.push(wall);
                })
                data.entities.wallsArray = newWallsArray;
            },

            initLevelSpecificEntities: function (data) {
                // clear all level specific entities from previous levels
                this.clearLevelSpecificEntities(data);

                // if the player has completed all of the levels, we'll take them back to level 1
                // but the enemies get tougher each time through
                if (!entitiesForLevel[data.gameLevel]) {
                    data.gameLevel = 1;
                    data.gameLevelResets++
                }

                // get the entities specific to this level
                var entitiesForThisLevel = entitiesForLevel[data.gameLevel];

                // if we're running test mode, overwrite the entities with the test mode entities for the level
                if (data.testMode) {
                    for (var key in entitiesForThisLevel.testMode) {
                        entitiesForThisLevel[key] = entitiesForThisLevel.testMode[key]
                    }
                }

                // if we're running a custom built map, use those entities instead
                if (data.playCustomMap) {
                    entitiesForThisLevel = data.customEntities;
                }

                // move the player to the start location for this level
                data.entities.player.x = entitiesForThisLevel.playerStartLocation.x
                data.entities.player.y = entitiesForThisLevel.playerStartLocation.y

                entitiesForThisLevel.obstacles.forEach(function (wall) {
                    var wallObj = new Entities.helpers.Wall(wall[0], wall[1], wall[2], wall[3], OBSTACLE);
                    var ignoreHudAreaWarning = wall[4];
                    hudCheck(wallObj, ignoreHudAreaWarning);
                    data.entities.wallsArray.push(wallObj)
                })

                entitiesForThisLevel.enemyLocations.forEach(function (enemy) {
                    var enemyObj;
                    // pattern chasers have an extra param
                    if (enemy[4] === 'PATTERNCHASER') {
                        enemyObj = new Entities.helpers.Enemy(enemy[0], enemy[1], enemy[2], enemy[3], enemy[4], enemy[5])
                    } else {
                        enemyObj = new Entities.helpers.Enemy(enemy[0], enemy[1], enemy[2], enemy[3], enemy[4]);
                    }

                    hudCheck(enemyObj);
                    data.entities.enemiesArray.push(enemyObj)
                })

                // put pieces of food on the board
                entitiesForThisLevel.foodLocations.forEach(function (food) {
                    var foodObj = new Entities.helpers.Food(food[0], food[1], food[2])
                    hudCheck(foodObj);
                    data.entities.foodArray.push(foodObj)
                })

                entitiesForThisLevel.moneyItems.forEach(function (obj) {
                    var moneyFoodObj = new Entities.helpers.MoneyFood(obj);
                    hudCheck(moneyFoodObj);
                    data.entities.moneyArray.push(moneyFoodObj);
                })

                entitiesForThisLevel.warpLocations.forEach(function (warpObject) {
                    var constructedExit = new Entities.helpers.Warp(warpObject.exit);
                    warpObject.exit = constructedExit;
                    var warpObj = new Entities.helpers.Warp(warpObject);
                    hudCheck(warpObj);
                    hudCheck(warpObj.exit);
                    data.entities.warpArray.push(warpObj);
                })

                // if we're repeating levels, make the enemies better
                // this if statement isn't really necessary because of the calculations we're
                // doing, but it's nice visually to see what's happening here
                if (data.gameLevelResets > 0) {
                    data.entities.enemiesArray.forEach(function (enemy) {
                        enemy.speed += data.gameLevelResets;
                        enemy.strength += (data.gameLevelResets * 100);
                        // at speeds greater than 8 (800) they tend to jump walls since walls are 8px thick
                        if (enemy.speed > 8) enemy.speed = 8;
                    })
                }
            },

            update: function (data) {
                data.entities.player.update(data);
                data.entities.enemiesArray.forEach(function (enemy) {
                    enemy.update(data);
                })
                data.entities.moneyArray.forEach(function (money) {
                    money.update(data);
                })
            },

            helpers: {
                player: function () {
                    var self = this;
                    this.type = PLAYER;
                    this.points = 0;

                    // x & y will get set per level so these values don't matter
                    this.x = 100;
                    this.y = 100;
                    this.w = 20;
                    this.h = 20;
                    this.color = 'white';
                    this.direction = 'right';
                    this.velY = 3;
                    this.velX = 3;
                    this.speed = 2;
                    this.lives = 3;
                    this.strength = 5;
                    // while in ghost state, user can pass through walls and cannot lost lives
                    this.inGhostState = false;
                    this.enteredGhostStateTimestamp = null;
                    this.ghostStateDuration = 5000;
                    // money is used to buy things in the shop
                    this.money = 40;
                    // food is worth this many extra points for the player
                    this.foodPointsIncrementer = 0;
                    // text is displayed inside the entity's visual box
                    this.text = function () {
                        return [this.strength, Math.round(this.speed * 100)]
                    }

                    this.update = function (data) {
                        this.color = 'white';
                        this.resetVelocities(data);
                        this.handleGhostStateIfNecessary(data);
                    }

                    // reset velocities in case they were set to 0 during a collision
                    this.resetVelocities = function (data) {
                        this.velX = this.speed;
                        this.velY = this.speed;
                        return;
                    }

                    this.handleGhostStateIfNecessary = function (data) {
                        if (this.inGhostState) {
                            // blink gray
                            this.color = 'gray';
                            if (data.animationFrame % 8 === 0) this.color = 'black';

                            // see if it's time to end ghost state
                            var now = new Date().getTime();
                            var ghostStateTimeElapsed = now - this.enteredGhostStateTimestamp;
                            if (ghostStateTimeElapsed > this.ghostStateDuration) {
                                this.inGhostState = false;
                                this.enteredGhostStateTimestamp = null;
                            }
                        }
                        return;
                    }
                },

                Wall: function (x, y, w, h, wallType = OBSTACLE) {
                    this.x = x;
                    this.y = y;
                    this.w = w;
                    this.h = h;
                    this.color = 'white';
                    this.type = WALL;
                    this.wallType = wallType;
                },

                Food: function (x, y, val) {
                    this.getColor = function () {
                        var colorMap = {
                            1: '#00f',
                            2: '#0f0',
                            3: '#cc2',
                            4: '#f5f',
                            5: '#0ff',
                            6: '#0f6',
                            7: '#ff0',
                            8: '#550',
                            9: '#992'
                        }
                        return colorMap[this.value]
                    }

                    // we use id during collision to remove proper item from array
                    this.id = random(100000, 1000000000);
                    this.x = x ? x : random(0, data.canvas.width)
                    this.y = y ? y : random(0, data.canvas.height)
                    this.w = 12;
                    this.h = 12;
                    this.size = '15px';
                    this.font = 'Arial';
                    this.value = val;
                    this.color = this.getColor();
                    this.type = FOOD;
                    // text is displayed inside the entity's visual box
                    this.text = function () {
                        return [this.value]
                    }
                },

                Enemy: function (x, y, strength, speed, enemyType, patternDestinations) {
                    // we'll use the id to make sure we delete the right enemy on collision
                    this.id = random(100000, 1000000000);
                    this.x = x;
                    this.y = y;
                    this.color = 'red';
                    this.type = ENEMY;
                    this.enemyType = enemyType ? enemyType : 'NORMAL';
                    // only used by PATTERNCHASERs, but ok to initialize here for everyone
                    this.pattern = {
                        destinations: patternDestinations,
                        currentDestinationIndex: 0
                    }
                    this.speed = speed;
                    this.size = 20;
                    this.w = this.size;
                    this.h = this.size;
                    // used to determine if the player kills the bot or vice versa
                    this.strength = strength;
                    // when the player is caught, the bots freeze for a bit
                    this.frozen = false;
                    this.frozenTimestamp = null;
                    // text is displayed inside the entity's visual box
                    this.text = function () {
                        return [this.strength, Math.round(this.speed * 100)]
                    }

                    this.update = function (data) {
                        // if enemy is frozen, see if it's time to unfreeze
                        // for now the freeze time will be equal to the speed, so faster ones are frozen longer
                        if (this.frozen) {
                            var now = new Date().getTime();
                            if (now - this.frozenTimestamp > this.speed * 1000) {
                                this.frozen = false;
                                this.frozenTimestamp = null;
                            }
                            return;
                        }

                        if (this.enemyType === 'PATTERNCHASER') {
                            // pattern chasers follow a set path rather than chase the player
                            return this.followPattern(data, this.speed);
                        }

                        var player = data.entities.player;
                        var isFloater = this.enemyType === 'FLOATER';

                        // pixel allowance for this enemy is based on their speed. Faster ones have a higher 
                        // chance of jumping a wall, so the pixel allowance is lower
                        var pixelAllowance = 5 - this.speed;
                        if (pixelAllowance < 1) pixelAllowance = 1;

                        if (player.x <= this.x) {
                            var newLeftLine = this.x - this.speed;
                            var canMoveLeft = isFloater ||
                                !areaContainsWall(newLeftLine, newLeftLine, this.y, this.y + this.h, pixelAllowance, data.wallsCache)
                            if (canMoveLeft) {
                                this.x -= this.speed;
                            }
                        }
                        if (player.x >= this.x) {
                            var newRightLine = this.x + this.w + this.speed;
                            var canMoveRight = isFloater ||
                                !areaContainsWall(newRightLine, newRightLine, this.y, this.y + this.h, pixelAllowance, data.wallsCache)
                            if (canMoveRight) {
                                this.x += this.speed;
                            }
                        }
                        if (player.y <= this.y) {
                            var newTopLine = this.y - this.speed;
                            var canMoveUp = isFloater ||
                                !areaContainsWall(this.x, this.x + this.w, newTopLine, newTopLine, pixelAllowance, data.wallsCache)
                            if (canMoveUp) {
                                this.y -= this.speed;
                            }
                        }
                        if (player.y >= this.y) {
                            var newBottomLine = this.y + this.h + this.speed;
                            var canMoveDown = isFloater ||
                                !areaContainsWall(this.x, this.x + this.w, newBottomLine, newBottomLine, pixelAllowance, data.wallsCache)
                            if (canMoveDown) {
                                this.y += this.speed
                            }
                        }
                    }

                    this.followPattern = function (data, pixelAllowance) {
                        /*
                            each one will have a pattern set for them
                            this.pattern = {
                                destinations:  [{x, y}, {x, y}, etc... however many stations you want]
                                currentDestinationIndex: 2 // I'm headed to x/y at index 2
                            }
                           each frame, check if we're at our destination. If so, up the index and go again
                           - after end of array, reset index to 1
                           if we aren't at our destination yet, move towards i
                        */
                        var currentDestination = this.pattern.destinations[this.pattern.currentDestinationIndex];
                        // manage our current destination
                        if (Math.abs(this.x - currentDestination.x) < pixelAllowance && Math.abs(this.y - currentDestination.y) < pixelAllowance) {
                            // we're close enough to head to the next destination
                            this.pattern.currentDestinationIndex++;
                            if (this.pattern.currentDestinationIndex >= this.pattern.destinations.length) {
                                this.pattern.currentDestinationIndex = 0;
                            }
                            currentDestination = this.pattern.destinations[this.pattern.currentDestinationIndex];
                        }

                        // head to our current destination
                        // NOTE: since we don't check for walls here, these are technically a form of floater
                        if (currentDestination.x < this.x) this.x -= this.speed;
                        if (currentDestination.x > this.x) this.x += this.speed;
                        if (currentDestination.y > this.y) this.y += this.speed;
                        if (currentDestination.y < this.y) this.y -= this.speed;
                    }
                },

                // can only be eaten when it's 'alive'
                MoneyFood: function (moneyObj) {
                    // we use the id for collisions to remove the right one from array
                    this.id = random(100000, 1000000000)
                    this.type = MONEYFOOD;
                    this.x = moneyObj.x;
                    this.y = moneyObj.y;
                    this.value = moneyObj.value;
                    this.delayFromStartToShow = moneyObj.delayFromStartToShow;
                    this.delayFromStartToDie = moneyObj.delayFromStartToDie;
                    this.w = 13;
                    this.h = 13;
                    this.color = 'green';
                    this.alive = false;

                    this.text = function () {
                        return ['$$']
                    }

                    this.update = function (data) {
                        // shows up when it should & dies when it should
                        var timeSinceLevelStart = new Date().getTime() - data.gameLevelStartTime;
                        if (timeSinceLevelStart > this.delayFromStartToShow && timeSinceLevelStart < this.delayFromStartToDie) {
                            this.alive = true;
                        } else {
                            this.alive = false;
                        }

                        // blinks sometimes & blinks faster before it dies
                        if (this.alive) {
                            var lifespan = this.delayFromStartToDie - this.delayFromStartToShow;
                            var timeAlive = timeSinceLevelStart - this.delayFromStartToShow;
                            var percentOfLifeLeft = Math.floor((lifespan - (timeAlive / lifespan)) * 100)
                            if (data.animationFrame % percentOfLifeLeft === 0) {
                                this.color = 'black'
                            } else {
                                this.color = 'green';
                            }
                        }
                    }
                },

                HUDText: function (y, value) {
                    this.x = 10;
                    this.y = y;
                    this.value = value;
                    this.size = '20px';
                    this.font = 'Arial';
                    this.color = 'green';
                    this.type = HUDTEXT
                },

                Warp: function (warpObject) {
                    this.type = WARP;
                    this.size = 5;
                    this.w = this.size;
                    this.h = this.size;
                    this.color = '#f00';
                    this.x = warpObject.x;
                    this.y = warpObject.y;
                    // the exit itself uses this constructor, so handle null exit attribute
                    this.exit = warpObject.exit ? warpObject.exit : null;
                }
            }
        }

        // Render Script
        var Render = {
            init: function (data) {
                Render.helpers.drawEntity(data.entities.background);
            },

            update: function (data) {
                this.clearCanvas(data.canvas);

                var levelText = new Entities.helpers.HUDText(27, 'Level: ' + data.gameLevel)
                var pointsText = new Entities.helpers.HUDText(46, 'Points: ' + data.entities.player.points)
                var livesText = new Entities.helpers.HUDText(64, 'Lives: ' + data.entities.player.lives)
                var pointsIncrementerText = new Entities.helpers.HUDText(82, 'Food Bonus: ' + data.entities.player.foodPointsIncrementer)

                Render.helpers.drawText(levelText);
                Render.helpers.drawText(pointsText);
                Render.helpers.drawText(livesText);
                Render.helpers.drawText(pointsIncrementerText);

                // draw all of the entities listed in arrays in the data object
                for (var entityType in data.entities) {
                    if (Array.isArray(data.entities[entityType])) {
                        data.entities[entityType].forEach(function (entity) {
                            if (entity.type === WARP) {
                                // the warp location changes size per animation frame
                                if (data.animationFrame % 2 === 0) {
                                    var radiusMap = { 0: entity.size, 1: entity.size * 0.7, 2: entity.size * 0.4 };
                                    var sizeForFrame = radiusMap[data.animationFrame % 3]
                                    entity.r = sizeForFrame
                                }
                                // draw the warp location entry point
                                Render.helpers.drawCircle(entity);

                                // draw the exit
                                entity.exit.r = entity.exit.size;
                                Render.helpers.drawCircle(entity.exit);
                            }
                            else if (entity.type === MONEYFOOD) {
                                if (entity.alive) {
                                    // money only gets drawn when it's alive
                                    Render.helpers.drawEntity(entity);
                                }
                            } else {
                                // everything else gets drawn always
                                Render.helpers.drawEntity(entity);
                            }
                        })
                    }
                }

                // draw the player last so they show up on top of everything else
                Render.helpers.drawEntity(data.entities.player);

            },

            clearCanvas: function (canvas) {
                // default to the game canvas
                if (!canvas) {
                    var gameCanvas = document.getElementById('gameCanvas')
                    canvas = {
                        canvas: gameCanvas,
                        context: gameCanvas.getContext('2d')
                    }
                }
                canvas.context.clearRect(0, 0, canvas.canvas.width, canvas.canvas.height)
            },

            helpers: {
                drawEntity: function (entity, ctx, color) {
                    // default ctx to the game canvas
                    if (!ctx) ctx = document.getElementById('gameCanvas').getContext('2d');

                    // if color is passed in but no ctx, fix that
                    if (!color && typeof ctx === 'string') {
                        color = ctx;
                        ctx = document.getElementById('gameCanvas').getContext('2d');
                    }

                    ctx.fillStyle = color ? color : entity.color ? entity.color : 'white';
                    ctx.fillRect(entity.x, entity.y, entity.w, entity.h);

                    // if the entity has text to display, draw that too
                    if (entity.text) {
                        var textArr = entity.text();
                        ctx.fillStyle = 'black';
                        ctx.font = 'bold 10px Arial';
                        var textX = entity.x + 1;
                        var textY = entity.y;
                        textArr.forEach(function (str) {
                            textY += 9;
                            ctx.fillText(str, textX, textY);
                        })
                    }
                },

                drawText: function (text, ctx) {
                    // default ctx to the game canvas
                    if (!ctx) ctx = document.getElementById('gameCanvas').getContext('2d');

                    // default values for drawing text
                    if (!text.font) text.font = 'Arial';
                    if (!text.color) text.color = 'white';
                    if (!text.size) text.size = '14px';

                    ctx.font = text.size + ' ' + text.font;
                    ctx.fillStyle = text.color;
                    ctx.fillText(text.value, text.x, text.y);
                },

                drawCircle: function (entity, ctx) {
                    // default ctx to the game canvas
                    if (!ctx) ctx = document.getElementById('gameCanvas').getContext('2d');

                    ctx.fillStyle = entity.color ? entity.color : 'white';
                    ctx.beginPath();
                    ctx.arc(entity.x, entity.y, entity.r, 0, 2 * Math.PI);
                    // ctx.stroke();
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        // Physics Script
        var Physics = {
            update: function (data) {
                Physics.collisionDetection(data);
            },

            collisionDetection: function (data) {
                var player = data.entities.player;

                function entityPlayerCollisionCheck(entity) {
                    var entityLeft = entity.x;
                    var entityRight = entity.x + entity.w;
                    var entityTop = entity.y;
                    var entityBottom = entity.y + entity.h;

                    // since warps are circles, their collision box is offset from center
                    if (entity.type === WARP) {
                        var offset = entity.size / 2
                        entityLeft -= offset;
                        entityRight -= offset;
                        entityTop -= offset;
                        entityBottom -= offset;
                    }

                    // check for collision
                    if (player.x < entityRight &&
                        player.x + player.w > entityLeft &&
                        player.y < entityBottom &&
                        player.y + player.h > entityTop) {
                        // Collision occurred
                        Physics.handlePlayerCollision(data, entity);
                    }
                }

                function enemyWallCollisionCheck(enemy, wall) {
                    if (enemy.x < wall.x + wall.w &&
                        enemy.x + enemy.w > wall.x &&
                        enemy.y < wall.y + wall.h &&
                        enemy.y + enemy.h > wall.y) {
                        // Collision occurred
                        Physics.handleEnemyWallCollision(data, enemy, wall);
                    }
                }

                // check for collision with any of the entities listed in arrays in the data object
                for (var entityType in data.entities) {
                    if (Array.isArray(data.entities[entityType])) {
                        data.entities[entityType].forEach(function (entity) {
                            entityPlayerCollisionCheck(entity);
                            // if it's an enemy, check if it's hitting any walls
                            if (entity.type === ENEMY) {
                                data.entities.wallsArray.forEach(function (wall) {
                                    enemyWallCollisionCheck(entity, wall);
                                })
                            }
                        })
                    }
                }
            },

            // for now I dont do anything here
            handleEnemyWallCollision(data, enemy, wall) {
            },

            // biggest freaking function in the game
            handlePlayerCollision(data, entity) {
                // easy to read variables
                var player = data.entities.player;
                var playerLeftSide = player.x;
                var playerRightSide = player.x + player.w;
                var playerTopSide = player.y;
                var playerBottomSide = player.y + player.h;

                // when in ghost state, collisions can't happen (except edge walls still work)
                var isEdgeWall = entity.type === WALL && entity.wallType === WALL;
                if (player.inGhostState && !isEdgeWall) return;

                if (entity.type === FOOD) {
                    // adjust the player's points
                    var foodPoints = entity.value + data.entities.player.foodPointsIncrementer
                    data.entities.player.points += foodPoints;

                    // remove the food from the array
                    removeFromArrayById(data.entities.foodArray, entity.id);

                    // check if the level is finished
                    if (data.entities.foodArray.length === 0) {
                        // pause the game (opens the shop) & go to the next level
                        // the pause is just for UX, doesn't really serve a purpose other
                        // than visually when you un-pause it it's on the next level
                        data.startNextLevel = true;
                    }
                }

                // food can only be eaten when it's alive
                if (entity.type === MONEYFOOD && entity.alive) {
                    // adjust the player's money
                    var moneyValue = entity.value;
                    data.entities.player.money += moneyValue;

                    // remove the money item from the array
                    removeFromArrayById(data.entities.moneyArray, entity.id);
                }

                if (entity.type === WALL) {
                    var wallLeftSide = entity.x;
                    var wallRightSide = entity.x + entity.w;
                    var wallTopSide = entity.y;
                    var wallBottomSide = entity.y + entity.h;
                    // if the user is barely in the wall they can still move since we don't move them pixel by pixel and they might jump into it slightly
                    var allowanceBuffer = player.speed;

                    // player is in between the walls borders and not trying to move the other way
                    if (!player.direction.right &&
                        playerLeftSide > wallLeftSide &&
                        playerLeftSide < wallRightSide &&
                        playerRightSide > wallRightSide &&
                        playerTopSide < wallBottomSide - allowanceBuffer &&
                        playerBottomSide > wallTopSide + allowanceBuffer) {
                        player.velX = 0;
                    }

                    if (!player.direction.left &&
                        playerRightSide > wallLeftSide &&
                        playerRightSide < wallRightSide &&
                        playerLeftSide < wallLeftSide &&
                        playerTopSide < wallBottomSide - allowanceBuffer &&
                        playerBottomSide > wallTopSide + allowanceBuffer) {
                        player.velX = 0;
                    }

                    if (!player.direction.down &&
                        playerTopSide > wallTopSide &&
                        playerTopSide < wallBottomSide &&
                        playerBottomSide > wallBottomSide &&
                        playerLeftSide < wallRightSide - allowanceBuffer &&
                        playerRightSide > wallLeftSide + allowanceBuffer) {
                        player.velY = 0;
                    }

                    if (!player.direction.up &&
                        playerBottomSide > wallTopSide &&
                        playerBottomSide < wallBottomSide &&
                        playerTopSide < wallTopSide &&
                        playerLeftSide < wallRightSide - allowanceBuffer &&
                        playerRightSide > wallLeftSide + allowanceBuffer) {
                        player.velY = 0;
                    }
                }

                if (entity.type === WARP) {
                    var offset = player.w / 2
                    player.x = entity.exit.x - offset;
                    player.y = entity.exit.y - offset;
                }

                if (entity.type === ENEMY) {
                    // enemy dies and player gets the points equal to their strength
                    // I could assign a enemy.pointValue if needed instead of their strength?
                    if (player.strength > entity.strength) {
                        removeFromArrayById(data.entities.enemiesArray, entity.id);
                        player.points += entity.strength;
                    }
                    // player loses a life and enters ghost state for a short time
                    // the enemy freezes momentarily while the player escapes
                    else {
                        player.lives--;
                        player.inGhostState = true;
                        player.enteredGhostStateTimestamp = new Date().getTime();

                        // check if game is over
                        if (player.lives < 1) {
                            data.gameOver = true;
                            data.gameRunning = false;

                            // save high score locally
                            return Game.handleHighScore(player.points);
                        }

                        // freezes all enemies once the player is hit
                        data.entities.enemiesArray.forEach(function (enemy) {
                            enemy.frozen = true;
                            enemy.frozenTimestamp = new Date().getTime();
                        })

                        // freezes just the enemy that hit the player
                        // entity.frozen = true;
                        // entity.frozenTimestamp = new Date().getTime();
                    }
                }
            }
        }

        // Game Script
        var Game = {
            // starts the game using the map built in the levelBuilder
            initCustom: function () {
                // cant start the map without food and a player obj
                if (foodLocations.length < 1 || !playerStartLocation) return;
                Game.init({
                    playCustomMap: true,
                    gameLevel: 1,
                    customEntities: {
                        playerStartLocation: playerStartLocation,
                        obstacles: obstacles,
                        foodLocations: foodLocations,
                        enemyLocations: enemyLocations,
                        warpLocations: warpLocations,
                        moneyItems: moneyItems
                    }
                })
            },
            init: function (settings) {
                if (!settings) settings = {};

                // close the rules and hide the new game button
                document.getElementById('hideDuringGameplay').style.display = 'none';

                // see what level the user wants to start on
                var gameLevelInput = document.getElementById('gameLevelInput')
                var userSelectedLevel = Number(gameLevelInput.value);
                var gameLevel = 1;
                // if it's higher than we have, start them on 1
                if (entitiesForLevel[userSelectedLevel]) gameLevel = userSelectedLevel;

                var cv = document.getElementById('gameCanvas');
                var ctx = cv.getContext('2d');

                var canvas = {
                    canvas: cv,
                    context: ctx
                }

                var data = {
                    animationFrame: 0,
                    canvas: canvas,
                    gameOver: false,
                    gameRunning: true,
                    gameLevel: gameLevel,
                    gameLevelStartTime: new Date().getTime(),
                    gameLevelResets: 0,
                    shopItems: this.buildShop(),
                    eventListeners: {},
                }

                // see if we're running test mode or not
                if (settings.testMode) data.testMode = true;

                // see if we're running a custom map or not
                if (settings.playCustomMap) {
                    data.playCustomMap = settings.playCustomMap;
                    data.customEntities = settings.customEntities;
                    data.gameLevel = settings.gameLevel;
                }

                // init game specific things
                Entities.init(data);
                Input.init(data);
                Render.init(data);

                // init level specific things
                Game.initLevel(data);

                // start the game loop
                Game.run(data);
            },

            initLevel(data) {
                // if we're playing on a custom map, return to the editor after finishing the level
                if (data.playCustomMap && data.gameLevel !== 1) {
                    data.gameOver = true;
                }

                // build level specific entities - walls, enemies, food, etc
                Entities.initLevelSpecificEntities(data);
                // cache the walls' locations for future reference
                data.wallsCache = this.buildWallsCache(data)
            },

            run: function (data) {
                window.gameLoopRunning = true;

                var loop = function () {
                    // end the loop if game is over
                    if (data.gameOver) {
                        window.gameLoopRunning = false;
                        Game.handleGameOver(data);
                        return;
                    }

                    // start the next level if needed
                    if (data.startNextLevel) {
                        data.startNextLevel = false;
                        data.gameRunning = false;
                        setTimeout(function () {
                            data.gameLevel++;
                            data.gameLevelStartTime = new Date().getTime();
                            Game.initLevel(data);
                        }, 1);
                    }

                    // if game is not paused, update things
                    if (data.gameRunning && !data.buildingLevel) {
                        Game.input(data);
                        Game.update(data);
                        Game.render(data);
                    } else {
                        Game.showMenu(data);
                    }

                    // keep the loop going
                    data.animationFrame++;
                    window.requestAnimationFrame(loop);
                }

                loop();
            },

            input: function (data) {
                Input.update(data);
            },

            update: function (data) {
                Entities.update(data);
                Physics.update(data);
            },

            render: function (data) {
                Render.update(data);
            },

            buildShop: function () {
                // for now all items are permanent upgrades and can be purchased infinite times. 
                // we can change either of those realities later if needed
                var shopItems = {
                    // trade points for money
                    KeyO: {
                        cost: 25,
                        costMultiplier: 1,
                        costType: 'money',
                        points: 4,
                    },
                    KeyP: {
                        cost: 50,
                        costMultiplier: 1,
                        costType: 'money',
                        points: 9,
                    },
                    KeyK: {
                        cost: 4,
                        costMultiplier: 1,
                        costType: 'points',
                        money: 20
                    },
                    KeyL: {
                        cost: 8,
                        costMultiplier: 1,
                        costType: 'points',
                        money: 42
                    },
                    // buy powerups
                    KeyQ: {
                        cost: 10,
                        costMultiplier: 1.5,
                        costType: 'money',
                        strength: 1,
                    },
                    KeyW: {
                        cost: 10,
                        costMultiplier: 1.5,
                        costType: 'money',
                        speed: 0.05,
                    },
                    KeyE: {
                        cost: 100,
                        costMultiplier: 1.2,
                        costType: 'money',
                        lives: 1
                    },
                    KeyR: {
                        cost: 500,
                        costMultiplier: 2,
                        costType: 'money',
                        foodPointsIncrementer: 1
                    }
                }
                return shopItems;
            },

            // our map is only 500x500, so this happens in a fraction of a 
            // second when the game loads (like 90ms)
            buildWallsCache: function (data) {
                var wallsCache = {};
                for (var i = 0; i < data.entities.wallsArray.length; i++) {
                    var wall = data.entities.wallsArray[i];
                    // for each x,y point in the wall, cache that location
                    for (var j = wall.x; j <= wall.x + wall.w; j++) {
                        for (var k = wall.y; k <= wall.y + wall.h; k++) {
                            var point = j + '|' + k;
                            wallsCache[point] = true;
                        }
                    }
                }
                return wallsCache;
            },

            handleGameOver(data) {
                // Display the new game button again so user can start game over
                document.getElementById('hideDuringGameplay').style.display = 'block';

                // unhook the event listeners
                $(window).off('keydown', data.eventListeners.handleKeyDown)
                $(window).off('keyup', data.eventListeners.handleKeyUp)
                $(window).off('keypress', data.eventListeners.handleKeyPress)

                // all movement keys up
                Input.allMovementKeysUp();

                // if we're playing a custom map, return to the editor
                if (data.playCustomMap) {
                    window.wall = true;
                    return drawEverything();
                }

                // otherwise show the final score
                var gameOverBox = {
                    x: data.canvas.canvas.width * 0.25,
                    y: data.canvas.canvas.height * 0.25,
                    w: data.canvas.canvas.width / 2,
                    h: data.canvas.canvas.height / 2,
                    color: '#222',
                }
                var gameOverText = {
                    x: gameOverBox.x + 10,
                    y: gameOverBox.y + 50,
                    size: '30px',
                    color: 'white',
                    value: 'Game Over'
                }
                var finalScoreText = {
                    x: gameOverText.x,
                    y: gameOverText.y + 30,
                    size: '26px',
                    value: 'Final Score: ' + data.entities.player.points
                }

                // show game over and points earned
                Render.helpers.drawEntity(gameOverBox);
                Render.helpers.drawText(gameOverText);
                Render.helpers.drawText(finalScoreText);

                // show local high score
                var localHighScoreInfo = this.getLocalHighScoreInfo();
                var savedHighScore = localHighScoreInfo.savedHighScore;
                var savedScoreValidation = localHighScoreInfo.savedScoreValidation;
                var isValidHighScore = this.validateHighScore(savedHighScore, savedScoreValidation);
                var fakeGameIdText = {
                    x: finalScoreText.x,
                    y: finalScoreText.y + 22,
                    value: 'Game Identifier: '
                }
                var scoreValidatorText = {
                    x: fakeGameIdText.x,
                    y: fakeGameIdText.y + 20,
                    value: random(100000, 999999) + '-' + savedScoreValidation + '-' + random(100000, 999999)
                }
                var highScoreText = {
                    x: scoreValidatorText.x,
                    y: scoreValidatorText.y + 40,
                    value: 'High Score: ' + savedHighScore
                }
                Render.helpers.drawText(fakeGameIdText)
                Render.helpers.drawText(scoreValidatorText)
                Render.helpers.drawText(highScoreText)
            },

            getLocalHighScoreInfo() {
                return {
                    savedHighScore: localStorage.highScore ? localStorage.highScore : 0,
                    savedScoreValidation: localStorage.scoreValidation ? localStorage.scoreValidation : 0
                }
            },

            handleHighScore(points) {
                try {
                    var localHighScoreInfo = this.getLocalHighScoreInfo();
                    var savedHighScore = localHighScoreInfo.savedHighScore;
                    var savedScoreValidation = localHighScoreInfo.savedScoreValidation;

                    // check if old high score is valid
                    var savedHighScoreIsValid = this.validateHighScore(savedHighScore, savedScoreValidation);

                    // if the old score isn't valid OR 
                    // the new score is higher than an old valid score, save the new one
                    if (!savedHighScoreIsValid || points > savedHighScore) {
                        localStorage.highScore = points;
                        localStorage.scoreValidation = this.createScoreValidation(points)
                    }
                } catch (e) {
                    console.log('Problem saving high score');
                    console.log(e)
                }
            },

            // this is just to keep track of if someone messed with the localStorage high score or not :)
            // this can take in a string or number and be fine
            createScoreValidation(points) {
                if (!points) {
                    return random(111111, 999999);
                }

                // put the points back to back
                var pointsStr = points.toString();
                var hash = 0;

                // put the points back to back & base 64 encode it
                var str = btoa(pointsStr + pointsStr);

                // hash it
                for (var i = 0; i < str.length; i++) {
                    var char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return hash;
            },

            // this is just to keep track of if someone messed with the localStorage high score or not :)
            // This function can take in strings or numbers and be fine
            validateHighScore(score, scoreValidation) {
                var trueValidation = Game.createScoreValidation(score);
                trueValidation = trueValidation.toString();
                scoreValidation = scoreValidation.toString();
                return trueValidation === scoreValidation
            },

            showMenu(data) {
                Render.clearCanvas(data.canvas);
                // title
                Render.helpers.drawText({
                    x: data.canvas.canvas.width / 2 - 80,
                    y: 50,
                    size: '25px',
                    value: 'Shop!!!'
                });
                // Shows the player
                Render.helpers.drawText({
                    x: data.canvas.canvas.width - 120,
                    y: 55,
                    value: 'You'
                });
                Render.helpers.drawText({
                    x: data.canvas.canvas.width - 120,
                    y: 80,
                    value: 'Points: ' + data.entities.player.points
                });
                Render.helpers.drawText({
                    x: data.canvas.canvas.width - 120,
                    y: 100,
                    value: 'Money: $' + data.entities.player.money
                });
                Render.helpers.drawText({
                    x: data.canvas.canvas.width - 120,
                    y: 120,
                    value: 'Strength: ' + data.entities.player.strength
                });
                Render.helpers.drawText({
                    x: data.canvas.canvas.width - 120,
                    y: 140,
                    value: 'Speed: ' + Math.round(data.entities.player.speed * 100)
                });

                // Trade points for money
                Render.helpers.drawText({
                    x: 20,
                    y: 80,
                    value: 'O: Trade $25 for 4 points'
                })
                Render.helpers.drawText({
                    x: 20,
                    y: 100,
                    value: 'P: Trade $50 for 9 points'
                })
                Render.helpers.drawText({
                    x: 20,
                    y: 120,
                    value: 'K: Trade 4 points for $20'
                })
                Render.helpers.drawText({
                    x: 20,
                    y: 140,
                    value: 'L: Trade 8 points for $42'
                })

                // shop items
                Render.helpers.drawText({
                    x: 20,
                    y: 210,
                    value: 'Q: Strength Potion - ' + data.shopItems.KeyQ.strength + ' strength - $' + data.shopItems.KeyQ.cost
                })
                Render.helpers.drawText({
                    x: 20,
                    y: 235,
                    value: 'W: Speed Potion - ' + (data.shopItems.KeyW.speed * 100) + ' speed - $' + data.shopItems.KeyW.cost
                })
                Render.helpers.drawText({
                    x: 20,
                    y: 260,
                    value: 'E: Extra Life - ' + data.shopItems.KeyE.lives + ' life - $' + data.shopItems.KeyE.cost
                })
                Render.helpers.drawText({
                    x: 20,
                    y: 285,
                    value: 'R: Increase food point values by ' + data.shopItems.KeyR.foodPointsIncrementer + ' - $' + data.shopItems.KeyR.cost
                })
            }
        }

        //
        //
        //
        //
        //
        // Level builder functions for local machine
        //
        //
        //
        //
        //        
        function initEmptyEntityValuesForEditor() {
            // start off drawing walls
            window.wall = true;
            window.warp = false;
            window.player = false;
            window.enemy = false;
            window.food = false;
            window.money = false;

            // empty objects
            window.playerStartLocation = {};
            window.playerObj = null;
            window.obstacles = [];
            window.foodLocations = [];
            window.enemyLocations = [];
            window.moneyItems = [];
            window.warpLocations = [];

            // default values
            window.foodValue = 1;
            window.moneyStartTime = 5000;
            window.deleteFromEditor = false;
        }
        initEmptyEntityValuesForEditor();

        function resetEditor() {
            initEmptyEntityValuesForEditor();
            drawEverything();
        }

        function drawEverything() {
            // if a game is in progress, do nothing
            if (window.gameLoopRumning) return;

            // clear board then draw everything
            Render.clearCanvas();

            var walls = hudWalls.concat(edgeWalls);
            walls.forEach(function (wall) {
                var wallObj = new Entities.helpers.Wall(wall[0], wall[1], wall[2], wall[3], WALL);
                Render.helpers.drawEntity(wallObj);
            })
            obstacles.forEach(function (wall) {
                var wallObj = new Entities.helpers.Wall(wall[0], wall[1], wall[2], wall[3], OBSTACLE)
                Render.helpers.drawEntity(wallObj);
            })
            foodLocations.forEach(function (obj) {
                var foodObj = new Entities.helpers.Food(obj[0], obj[1], obj[2]);
                Render.helpers.drawEntity(foodObj)
            })
            enemyLocations.forEach(function (enemy) {
                var enemyObj = new Entities.helpers.Enemy(enemy[0], enemy[1], enemy[2], enemy[3], enemy[4]);
                Render.helpers.drawEntity(enemyObj)
            })
            moneyItems.forEach(function (moneyObj) {
                var money = new Entities.helpers.MoneyFood(moneyObj);
                Render.helpers.drawEntity(money)
            })
            warpLocations.forEach(function (warpObj) {
                var exit = new Entities.helpers.Warp(warpObj.exit);
                var warp = new Entities.helpers.Warp(warpObj);
                warp.r = warp.size
                exit.r = exit.size;
                warp.exit = exit;
                Render.helpers.drawCircle(warp);
                Render.helpers.drawCircle(exit);
            })
            // draw the player obj  
            if (window.playerObj) {
                Render.helpers.drawEntity(window.playerObj)
            }
        }

        // draw the edge/hud walls right off the bat
        drawEverything();

        function copyObstacles() {
            var obs = (JSON.stringify(obstacles))
            console.log(obs)
        }

        function copyFood() {
            var foodStr = (JSON.stringify(foodLocations))
            console.log(foodStr)
        }

        function copyEnemies() {
            var enemyLocationsStr = (JSON.stringify(enemyLocations))
            console.log(enemyLocationsStr)
        }

        function copyMoney() {
            console.log(JSON.stringify(moneyItems))
        }

        function copyWarps() {
            console.log(JSON.stringify(warpLocations))
        }

        function copyMap() {
            var customEntities = {
                playerStartLocation: playerStartLocation,
                obstacles: obstacles,
                enemyLocations: enemyLocations,
                foodLocations: foodLocations,
                moneyItems: moneyItems,
                warpLocations: warpLocations
            }
            console.log(JSON.stringify(customEntities))
        }

        // copy in what's already there for the level to start from that point
        function startFromSave(obj) {
            /*
            example object
                {
                    playerStartLocation: { x: 64, y: 98 },
                    obstacles: [],
                    enemyLocations: [],
                    foodLocations: [],
                    moneyItems: [],
                    warpLocations: [],
                }
            */
            window.playerStartLocation = obj.playerStartLocation
            window.playerObj = new Entities.helpers.player(obj.playerStartLocation);
            window.playerObj.x = obj.playerStartLocation.x;
            window.playerObj.y = obj.playerStartLocation.y;
            obstacles = obj.obstacles;
            enemyLocations = obj.enemyLocations;
            foodLocations = obj.foodLocations;
            moneyItems = obj.moneyItems;
            warpLocations = obj.warpLocations;

            drawEverything();
        }

        $(window).on('keypress', function (event) {
            // if a game is in progress, do nothing
            if (window.gameLoopRunning) return;

            // hit "T" 3 times in a row to start test map
            if (event.code === 'KeyT') {
                if (!window.timesTPressed) window.timesTPressed = 0;
                window.timesTPressed++;
                if (window.timesTPressed >= 3) {
                    window.timesTPressed = 0;
                    Game.init({ testMode: true })
                }
            } else {
                window.timesTPressed = 0;
            }

            // hit "C" 3 times in a row to start test map
            if (event.code === 'KeyC') {
                if (!window.timesCPressed) window.timesCPressed = 0;
                window.timesCPressed++;
                if (window.timesCPressed >= 3) {
                    Game.initCustom();
                }
            } else {
                window.timesCPressed = 0;
            }

            // hitting 'D' toggles delete functionality to remove things from board
            // if (event.code === 'KeyD') {
            //     window.deleteFromEditor = !window.deleteFromEditor;
            // }

            // if we're placing food, the numbers will switch the food value for the next one to go down
            if (event.keyCode >= 49 && event.keyCode <= 57 && window.food) {
                return window.foodValue = Number(event.key)
            }

            var keyMap = {
                KeyE: 'enemy',
                KeyF: 'food',
                KeyW: 'warp',
                KeyO: 'wall',
                KeyM: 'money',
                KeyP: 'player',
                KeyD: 'deleteFromEditor'
            }
            for (var key in keyMap) {
                window[keyMap[key]] = false;
            }
            var activeCommand = keyMap[event.code];
            window[activeCommand] = true;

            return;
        })

        $('#gameCanvas').on('click', function (event) {
            var point = [event.offsetX, event.offsetY];

            // if a game is running, do nothing
            if (window.gameLoopRumning) return;

            // check if we're deleting or placing items
            if (window.deleteFromEditor) {
                return removeItemFromEditor(point);
            }

            if (window.player) {
                point[0] -= 10;
                point[1] -= 10
                if (!window.playerObj) {
                    window.playerObj = new Entities.helpers.player();
                }
                window.playerObj.x = point[0];
                window.playerObj.y = point[1];
                playerStartLocation = { x: point[0], y: point[1] }
                console.log(point);
            }

            if (window.food) {
                point[0] -= 6
                point[1] -= 6
                point.push(window.foodValue);
                foodLocations.push(point);
            }

            if (window.enemy) {
                point[0] -= 10
                point[1] -= 10
                point.push(20, 1.4, enemyType.NORMAL);
                enemyLocations.push(point);
            }

            if (window.warp) {
                point[0] -= 1;
                point[1] -= 1
                if (!window.beginWarpPoint) {
                    window.beginWarpPoint = point;
                } else {
                    warpLocations.push({
                        x: window.beginWarpPoint[0],
                        y: window.beginWarpPoint[1],
                        exit: { x: point[0], y: point[1] }
                    })
                    window.beginWarpPoint = null;
                }
            }

            if (window.money) {
                point[0] -= 4;
                point[1] -= 4;
                moneyItems.push({
                    x: point[0], y: point[1], value: 20,
                    delayFromStartToShow: moneyStartTime,
                    delayFromStartToDie: moneyStartTime + 30000
                })
                moneyStartTime += 10000
            }

            if (window.wall) {
                if (!window.beginPoint) {
                    window.beginPoint = point;
                } else {
                    // make it so clicking any direction will work
                    if (window.beginPoint[0] > point[0]) {
                        var temp = window.beginPoint[0];
                        window.beginPoint[0] = point[0]
                        point[0] = temp;
                    }
                    if (window.beginPoint[1] > point[1]) {
                        var temp = window.beginPoint[1];
                        window.beginPoint[1] = point[1];
                        point[1] = temp;
                    }

                    // make the wall 8 pixels thick
                    var width = point[0] - window.beginPoint[0];
                    var height = point[1] - window.beginPoint[1];
                    if (width > height) height = 8;
                    else width = 8;

                    // draw the wall
                    window.beginPoint.push(width, height)
                    obstacles.push(window.beginPoint);
                    window.beginPoint = null;
                }
            }

            drawEverything();
            return;
        })

        function itemContainsPoint(item, point) {
            if (point.x > item.x && point.x < item.x + item.w &&
                point.y > item.y && point.y < item.y + item.h) {
                return true;
            }
            return false;
        }

        function removeItemFromEditor(point) {
            var pointObj = {
                x: point[0],
                y: point[1]
            }

            // check if the player object is right there
            if (playerObj && itemContainsPoint(playerObj, pointObj)) {
                window.playerObj = null;
                window.playerStartLocation = null;
            }

            // helper function to build object from 4 values
            function buildTestableObj(x, y, w, h) {
                return {
                    x: x,
                    y: y,
                    w: w,
                    h: h
                }
            }

            // check warp locations
            warpLocations.forEach(function (obj, i) {
                var testableObj = buildTestableObj(obj.x - 5, obj.y - 5, 10, 10);
                var testableExitObj = buildTestableObj(obj.exit.x - 5, obj.exit.y - 5, 10, 10)
                if (itemContainsPoint(testableObj, pointObj) || itemContainsPoint(testableExitObj, pointObj)) {
                    warpLocations.splice(i, 1);
                }
            })

            // check money locations
            moneyItems.forEach(function (obj, i) {
                var testableObj = buildTestableObj(obj.x, obj.y, 13, 13);
                if (itemContainsPoint(testableObj, pointObj)) {
                    moneyItems.splice(i, 1);
                }
            })

            // check obstacles
            obstacles.forEach(function (arr, i) {
                var testableObj = buildTestableObj(arr[0], arr[1], arr[2], arr[3]);
                if (itemContainsPoint(testableObj, pointObj)) {
                    obstacles.splice(i, 1);
                }
            })

            foodLocations.forEach(function (arr, i) {
                var testableObj = buildTestableObj(arr[0], arr[1], 12, 12);
                if (itemContainsPoint(testableObj, pointObj)) {
                    foodLocations.splice(i, 1);
                }
            })

            enemyLocations.forEach(function (arr, i) {
                var testableObj = buildTestableObj(arr[0], arr[1], 20, 20);
                if (itemContainsPoint(testableObj, pointObj)) {
                    enemyLocations.splice(i, 1);
                }
            })

            drawEverything();
        }

    </script>

</body>

</html>