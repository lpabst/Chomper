<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Chomper</title>
</head>

<body>
    <style>
        #gameCanvas {
            width: 1000px;
            height: 600px;
            background: black;
        }
    </style>

    <main>
        <canvas id='gameCanvas'></canvas>
    </main>

    <script src="https://code.jquery.com/jquery-3.4.1.min.js"
        integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
    <script>
        // set the w/h of the canvas
        document.getElementById('gameCanvas').width = 1000;
        document.getElementById('gameCanvas').height = 600;

        // types
        var WALL = 'WALL';
        var OBSTACLE = 'OBSTACLE';
        var PLAYER = 'PLAYER';
        var ENEMY = 'ENEMY';
        var FOOD = 'FOOD';
        var SCORE = 'SCORE';
        var LIVES = 'LIVES';
        var enemyType = {
            NORMAL: 'NORMAL', // default
            TANK: 'TANK', // slow and increased strength
            SPEEDY: 'SPEEDY', // fast and decreased strength
            FLOATER: 'FLOATER' // slow and can go through walls
        }

        function random(low, high, includeHigh) {
            var inclusiveIncrementer = includeHigh ? 1 : 0
            return Math.floor(Math.random() * (high - low + inclusiveIncrementer)) + low;
        }

        // Player input
        var Input = {
            init: function (data) {
                this.setMovementKeys(data);
                this.setMenuKeys(data);
            },

            setMovementKeys: function (data) {
                $(window).on('keydown', function () {
                    // keeps arrow keys from scrolling the page
                    if (event.keyCode >= 37 && event.keyCode <= 40) {
                        event.preventDefault();
                    }
                    Input.helpers.down[event.keyCode] = true;
                });

                $(window).keyup(function () {
                    delete Input.helpers.down[event.keyCode];
                    delete Input.helpers.pressed[event.keyCode];
                })
            },

            setMenuKeys: function (data) {
                $(window).on('keypress', function () {
                    // space bar pauses game which opens menu
                    if (event.keyCode === 32) {
                        data.gameRunning = !data.gameRunning;
                    }
                    // while menu is open, hotkeys trigger menu transactions
                    if (!data.gameRunning) {
                        Input.handleShopPurchases(data, event);
                    }
                })
            },

            handleShopPurchases(data, event) {
                // for now all items are permanent upgrades and can be purchased infinite times. 
                // we can change either of those realities later if needed
                var shopItems = {
                    // trade points for money
                    KeyO: {
                        cost: 25,
                        costType: 'money',
                        points: 4,
                    },
                    KeyP: {
                        cost: 50,
                        costType: 'money',
                        points: 9,
                    },
                    KeyK: {
                        cost: 4,
                        costType: 'points',
                        money: 20
                    },
                    KeyL: {
                        cost: 8,
                        costType: 'points',
                        money: 42
                    },
                    // buy powerups
                    KeyQ: {
                        cost: 10,
                        costType: 'money',
                        strength: 1,
                    },
                    KeyW: {
                        cost: 10,
                        costType: 'money',
                        speed: 0.2,
                    },
                    KeyE: {
                        cost: 100,
                        costType: 'money',
                        lives: 1
                    },
                    KeyR: {
                        cost: 500,
                        costType: 'money',
                        foodPointsIncrementer: 1
                    }
                }
                var shopItem = shopItems[event.code];
                if (!shopItem) return;

                var player = data.entities.player;
                // costType could be money or points
                var playersBalanceOfCostType = player[shopItem.costType]
                // see if player can purchase
                if (playersBalanceOfCostType < shopItem.cost) {
                    return alert('You dont have enough ' + shopItem.costType + ' for that item. \nCost: ' + shopItem.cost + ' \nYou have ' + playersBalanceOfCostType)
                }

                // copy the item so we can change it without changing the store's items
                var changesToPlayer = JSON.parse(JSON.stringify(shopItem));

                // the cost type is either points/money so we change that attribute on the player
                // object by the cost amount * -1
                changesToPlayer[shopItem.costType] = changesToPlayer.cost * -1;
                delete changesToPlayer.cost;
                delete changesToPlayer.costType;

                // at this point the item represents the changes to the player object that need to happen
                for (var key in changesToPlayer) {
                    player[key] += changesToPlayer[key]
                }

                // each time something is purchased, redraw the menu
                Game.showMenu(data)
            },

            update: function (data) {
                var player = data.entities.player;
                var leftArrowDown = Input.helpers.isDown(37);
                var rightArrowDown = Input.helpers.isDown(39);
                var upArrowDown = Input.helpers.isDown(38);
                var downArrowDown = Input.helpers.isDown(40);

                player.direction = {
                    left: false,
                    up: false,
                    right: false,
                    down: false
                }

                if (leftArrowDown) {
                    player.x -= player.velX
                    player.direction.left = true;
                }

                if (rightArrowDown) {
                    player.x += player.velX;
                    player.direction.right = true;
                }

                if (upArrowDown) {
                    player.y -= player.velY;
                    player.direction.up = true;
                }

                if (downArrowDown) {
                    player.y += player.velY;
                    player.direction.down = true;
                }
            },

            helpers: {
                isDown: function (code) {
                    return Input.helpers.down[code];
                },

                isPressed: function (code) {
                    if (Input.helpers.pressed[code]) {
                        return false;
                    } else if (Input.helpers.down[code]) {
                        return Input.helpers.pressed[code] = true;
                    } else {
                        return false;
                    }
                },

                down: {},
                pressed: {},
            },
        }

        // Entities Script
        var Entities = {
            init: function (data) {
                var background = {
                    x: 0,
                    y: 0,
                    w: 1000,
                    h: 800,
                };

                var player = new Entities.helpers.player(300, 300);

                // HUD area 0 - 140 && 0 - 88
                var hudWalls = [[0, 80, 140, 8, true], [140, 0, 8, 88, true]];
                var edgeWalls = [[0, 0, 1000, 8, true], [0, 0, 8, 1000, true], [0, 1000, 1000, 8, true], [1000, 0, 8, 1000, true]]
                var obstacles = [[80, 420, 420, 8], [170, 20, 600, 8], [620, 20, 8, 80], [120, 110, 480, 8], [170, 45, 8, 55], [200, 20, 8, 55], [300, 45, 8, 55], [400, 20, 8, 55]];
                var wallLocations = hudWalls.concat(edgeWalls);

                var enemyLocations = [
                    // [200, 200, 20, 2, enemyType.NORMAL],
                    // [500, 200, 20, 2, enemyType.NORMAL],
                    // [200, 300, 20, 2, enemyType.NORMAL],
                    // [300, 200, 20, 2, enemyType.NORMAL],
                    // [500, 320, 10, 3.05, enemyType.SPEEDY],
                    // [800, 150, 50, 1, enemyType.TANK],
                    [50, 500, 20, 1, enemyType.FLOATER],
                ]

                var foodLocations = [
                    [300, 400, 1],
                    [350, 400, 2],
                    [400, 400, 3],
                    [450, 400, 4],
                    [500, 400, 5],
                    [550, 400, 6],
                    [600, 400, 7],
                    [650, 400, 8],
                    [700, 400, 9],
                ]

                data.entities = {
                    background: background,
                    player: player,
                    wallsArray: [],
                    enemiesArray: [],
                    foodArray: [],
                };

                // see if anything is in the HUD area
                function hudCheck(entity, ignoreHudAreaWarning) {
                    for (var i = 0; i < hudWalls.length; i++) {
                        if (!ignoreHudAreaWarning && entity.x < hudWalls[i][0] + hudWalls[i][2] && entity.y < hudWalls[i][1] + hudWalls[i][3]) {
                            console.warn('In the HUD area');
                            console.log(entity);
                        }
                    }
                }


                wallLocations.forEach(function (wall) {
                    var wallObj = new Entities.helpers.Wall(wall[0], wall[1], wall[2], wall[3], WALL);
                    var ignoreHudAreaWarning = wall[4];
                    hudCheck(wallObj, ignoreHudAreaWarning);
                    data.entities.wallsArray.push(wallObj)
                })

                obstacles.forEach(function (wall) {
                    var wallObj = new Entities.helpers.Wall(wall[0], wall[1], wall[2], wall[3], OBSTACLE);
                    var ignoreHudAreaWarning = wall[4];
                    hudCheck(wallObj, ignoreHudAreaWarning);
                    data.entities.wallsArray.push(wallObj)
                })

                enemyLocations.forEach(function (enemy) {
                    var enemyObj = new Entities.helpers.Enemy(enemy[0], enemy[1], enemy[2], enemy[3], enemy[4]);
                    hudCheck(enemyObj);
                    data.entities.enemiesArray.push(enemyObj)
                })

                // put pieces of food on the board
                foodLocations.forEach(function (food) {
                    var foodObj = new Entities.helpers.Food(food[0], food[1], food[2])
                    hudCheck(foodObj, false);
                    data.entities.foodArray.push(foodObj)
                })
            },

            update: function (data) {
                data.entities.player.update(data);
                data.entities.enemiesArray.forEach(function (enemy) {
                    enemy.update(data);
                })
            },

            helpers: {
                player: function (x, y, w, h) {
                    var self = this;
                    this.type = PLAYER;
                    this.points = 0;

                    this.x = x;
                    this.y = y;
                    this.w = 20;
                    this.h = 20;
                    this.color = 'white';
                    this.direction = 'right';
                    this.velY = 3;
                    this.velX = 3;
                    this.speed = 3;
                    this.lives = 50;
                    this.strength = 5;
                    // while in ghost state, user can pass through walls and cannot lost lives
                    this.inGhostState = false;
                    this.enteredGhostStateTimestamp = null;
                    this.ghostStateDuration = 5000;
                    // money is used to buy things in the shop
                    this.money = 2000;
                    // food is worth this many extra points for the player
                    this.foodPointsIncrementer = 0;

                    this.update = function (data) {
                        this.color = 'white';
                        this.resetVelocities(data);
                        this.handleGhostStateIfNecessary(data);
                    }

                    // reset velocities in case they were set to 0 during a collision
                    this.resetVelocities = function (data) {
                        this.velX = this.speed;
                        this.velY = this.speed;
                        return;
                    }

                    this.handleGhostStateIfNecessary = function (data) {
                        if (this.inGhostState) {
                            // blink gray
                            this.color = 'gray';
                            if (data.animationFrame % 8 === 0) this.color = 'black';

                            // see if it's time to end ghost state
                            var now = new Date().getTime();
                            var ghostStateTimeElapsed = now - this.enteredGhostStateTimestamp;
                            if (ghostStateTimeElapsed > this.ghostStateDuration) {
                                this.inGhostState = false;
                                this.enteredGhostStateTimestamp = null;
                            }
                        }
                        return;
                    }
                },

                Wall: function (x, y, w, h, wallType = OBSTACLE) {
                    this.x = x;
                    this.y = y;
                    this.w = w;
                    this.h = h;
                    this.color = 'white';
                    this.type = WALL;
                    this.wallType = wallType;
                },

                Food: function (x, y, val) {
                    this.getColor = function () {
                        var colorMap = {
                            1: '#00f',
                            2: '#0f0',
                            3: '#cc2',
                            4: '#f5f',
                            5: '#0ff',
                            6: '#0f6',
                            7: '#ff0',
                            8: '#550',
                            9: '#992'
                        }
                        return colorMap[this.value]
                    }

                    this.x = x ? x : random(0, data.canvas.width)
                    this.y = y ? y : random(0, data.canvas.height)
                    this.w = 12;
                    this.h = 12;
                    this.size = '15px';
                    this.font = 'Arial';
                    this.value = val;
                    this.color = this.getColor();
                    this.type = FOOD;
                },

                Enemy: function (x, y, strength, speed, enemyType = 'normal') {
                    // we'll use the id to make sure we delete the right enemy on collision
                    this.id = random(0, 1000000000);
                    this.x = x;
                    this.y = y;
                    this.color = 'red';
                    this.type = ENEMY;
                    this.enemyType = enemyType;
                    this.speed = speed;
                    // used to determine if the player kills the bot or vice versa
                    this.strength = strength;
                    // when the player is caught, the bots freeze for a bit
                    this.frozen = false;
                    this.frozenTimestamp = null;
                    // keeps track of which sides of the bot are against a wall
                    this.againstWall = {
                        left: false,
                        right: false,
                        top: false,
                        bottom: false
                    }
                    // used when the bot can't move towards the player due to a wall
                    this.randomSide = 'left';

                    // faster ones are bigger so you can lose them in small spaces
                    var sizeMap = {
                        normal: 20,
                        tank: 15,
                        lightweight: 30
                    }
                    // default size is 20
                    this.size = 20;
                    if (sizeMap[this.enemyType]) {
                        this.size = sizeMap[this.enemyType]
                    }
                    this.w = this.size;
                    this.h = this.size;

                    this.update = function (data) {

                        var player = data.entities.player;

                        // if enemy is not frozen, move somewhere
                        if (!this.frozen) {
                            var hasMoved = false;
                            // move towards the player if possible
                            if (player.x < this.x && !this.againstWall.left) {
                                hasMoved = true;
                                this.x -= this.speed;
                            }
                            if (player.x > this.x && !this.againstWall.right) {
                                hasMoved = true;
                                this.x += this.speed;
                            }
                            if (player.y < this.y && !this.againstWall.top) {
                                hasMoved = true;
                                this.y -= this.speed;
                            }
                            if (player.y > this.y && !this.againstWall.bottom) {
                                hasMoved = true;
                                this.y += this.speed;
                            }
                            // if enemy hasn't moved yet, try and move any direction we're able
                            if (!hasMoved) {
                                var sides = ['left', 'right', 'top', 'bottom'];

                                // take out sides that are against a wall
                                for (var i = sides.length - 1; i >= 0; i--) {
                                    if (this.againstWall[sides[i]]) {
                                        sides.splice(i, 1)
                                    }
                                }

                                if (sides.length === 0) {
                                    // bot is stuck inside 4 walls. this should never happen
                                    console.log('bot is stuck on all 4 walls. how?')
                                } else {
                                    this.moveRandom(sides);
                                }
                            }
                        }

                        // if enemy is frozen, see if it's time to unfreeze
                        // for now the freeze time will be equal to the speed, so faster ones are frozen longer
                        if (this.frozen) {
                            var now = new Date().getTime();
                            if (now - this.frozenTimestamp > this.speed * 1000) {
                                this.frozen = false;
                                this.frozenTimestamp = null;
                            }
                        }

                        // after updating the location reset the wall info
                        this.againstWall = {
                            left: false,
                            right: false,
                            top: false,
                            bottom: false
                        }
                    }

                    this.moveRandom = function (availableSides) {
                        // random side only switches when it's against a wall that prevents current randomSide movement
                        if (!availableSides.includes(this.randomSide)) {
                            this.randomSide = availableSides[random(0, availableSides.length)];
                        }
                        // move in that direction
                        if (this.randomSide === 'left') this.x -= this.speed;
                        if (this.randomSide === 'right') this.x += this.speed;
                        if (this.randomSide === 'top') this.y -= this.speed;
                        if (this.randomSide === 'bottom') this.y += this.speed;
                        return;
                    }
                },

                Score: function (value) {
                    this.x = 10;
                    this.y = 30;
                    this.value = value;
                    this.size = "25px";
                    this.font = 'Arial';
                    this.color = 'green';
                    this.type = SCORE;
                },

                Lives: function (value) {
                    this.x = 10;
                    this.y = 60;
                    this.value = value;
                    this.size = "25px";
                    this.font = 'Arial';
                    this.color = 'green';
                    this.type = LIVES;
                }
            }
        }

        // Render Script
        var Render = {
            init: function (data) {
                Render.helpers.drawEntity(data.entities.background);
            },

            update: function (data) {
                this.clearCanvas(data.canvas);

                var pointsText = new Entities.helpers.Score('Points: ' + data.entities.player.points)
                var livesText = new Entities.helpers.Lives('Lives: ' + data.entities.player.lives)

                Render.helpers.drawText(pointsText);
                Render.helpers.drawText(livesText);

                // draw all of the entities listed in arrays in the data object
                for (var entityType in data.entities) {
                    if (Array.isArray(data.entities[entityType])) {
                        data.entities[entityType].forEach(function (entity) {
                            Render.helpers.drawEntity(entity);
                        })
                    }
                }

                // draw the player last so they show up on top of everything else
                Render.helpers.drawEntity(data.entities.player);

            },

            clearCanvas: function (canvas) {
                canvas.context.clearRect(0, 0, canvas.canvas.width, canvas.canvas.height)
            },

            helpers: {
                drawEntity: function (entity, ctx, color) {
                    // default ctx to the game canvas
                    if (!ctx) ctx = document.getElementById('gameCanvas').getContext('2d');

                    // if color is passed in but no ctx, fix that
                    if (!color && typeof ctx === 'string') {
                        color = ctx;
                        ctx = document.getElementById('gameCanvas').getContext('2d');
                    }

                    ctx.fillStyle = color ? color : entity.color ? entity.color : 'white';
                    ctx.fillRect(entity.x, entity.y, entity.w, entity.h);
                },

                drawText: function (text, ctx) {
                    // default ctx to the game canvas
                    if (!ctx) ctx = document.getElementById('gameCanvas').getContext('2d');

                    // default values for drawing text
                    if (!text.font) text.font = 'Arial';
                    if (!text.color) text.color = 'white';
                    if (!text.size) text.size = '20px';

                    ctx.font = text.size + ' ' + text.font;
                    ctx.fillStyle = text.color;
                    ctx.fillText(text.value, text.x, text.y);
                }
            }
        }

        // Physics Script
        var Physics = {
            update: function (data) {
                Physics.collisionDetection(data);
            },

            collisionDetection: function (data) {
                var player = data.entities.player;

                function entityPlayerCollisionCheck(entity) {
                    if (player.x < entity.x + entity.w &&
                        player.x + player.w > entity.x &&
                        player.y < entity.y + entity.h &&
                        player.y + player.h > entity.y) {
                        // Collision occurred
                        Physics.handlePlayerCollision(data, entity);
                    }
                }

                function enemyWallCollisionCheck(enemy, wall) {
                    if (enemy.x < wall.x + wall.w &&
                        enemy.x + enemy.w > wall.x &&
                        enemy.y < wall.y + wall.h &&
                        enemy.y + enemy.h > wall.y) {
                        // Collision occurred
                        Physics.handleEnemyWallCollision(data, enemy, wall);
                    }
                }

                // check for collision with any of the entities listed in arrays in the data object
                for (var entityType in data.entities) {
                    if (Array.isArray(data.entities[entityType])) {
                        data.entities[entityType].forEach(function (entity) {
                            entityPlayerCollisionCheck(entity);
                            // if it's an enemy, check if it's hitting any walls
                            if (entity.type === ENEMY) {
                                data.entities.wallsArray.forEach(function (wall) {
                                    enemyWallCollisionCheck(entity, wall);
                                })
                            }
                        })
                    }
                }
            },

            // keep track of which side of the enemy the wall is on
            handleEnemyWallCollision(data, enemy, wall) {
                // floaters go through walls
                if (enemy.enemyType === enemyType.FLOATER) return;

                // easy to read variable names
                var enemyLeftSide = enemy.x;
                var enemyRightRisde = enemy.x + enemy.w;
                var enemyTopSide = enemy.y;
                var enemyBottomSide = enemy.y + enemy.h;
                var wallLeftSide = wall.x;
                var wallRightSide = wall.x + wall.w;
                var wallTopSide = wall.y;
                var wallBottomSide = wall.y + wall.h;

                var againstWall = {
                    left: true,
                    right: true,
                    top: true,
                    bottom: true
                }

                // simple logic. Can be improved if needed
                if (wallBottomSide > enemyBottomSide) againstWall.top = false;
                if (wallTopSide < enemyTopSide) againstWall.bottom = false;
                if (wallLeftSide < enemyLeftSide) againstWall.right = false;
                if (wallRightSide < enemyRightRisde) againstWall.right = false;

                enemy.againstWall = againstWall;
            },

            // biggest freaking function in the game
            handlePlayerCollision(data, entity) {
                // easy to read variables
                var player = data.entities.player;
                var playerLeftSide = player.x;
                var playerRightSide = player.x + player.w;
                var playerTopSide = player.y;
                var playerBottomSide = player.y + player.h;

                // when in ghost state, collisions can't happen (except edge walls still work)
                var isEdgeWall = entity.type === WALL && entity.wallType === WALL;
                if (player.inGhostState && !isEdgeWall) return;

                if (entity.type === FOOD) {
                    // adjust the player's points
                    var foodPoints = entity.value + data.entities.player.foodPointsIncrementer
                    data.entities.player.points += foodPoints;

                    // remove the food from the array
                    var indexToRemove = data.entities.foodArray.indexOf(entity);
                    data.entities.foodArray.splice(indexToRemove, 1)

                    // check if the level is finished
                    if (data.entities.foodArray.length === 0) {
                        // go to the next level at some point
                    }
                }

                if (entity.type === WALL) {
                    var wallLeftSide = entity.x;
                    var wallRightSide = entity.x + entity.w;
                    var wallTopSide = entity.y;
                    var wallBottomSide = entity.y + entity.h;
                    // if the user is barely in the wall they can still move since we don't move them pixel by pixel and they might jump into it slightly
                    var allowanceBuffer = player.speed;

                    // player is in between the walls borders and not trying to move the other way
                    if (!player.direction.right &&
                        playerLeftSide > wallLeftSide &&
                        playerLeftSide < wallRightSide &&
                        playerRightSide > wallRightSide &&
                        playerTopSide < wallBottomSide - allowanceBuffer &&
                        playerBottomSide > wallTopSide + allowanceBuffer) {
                        player.velX = 0;
                    }

                    if (!player.direction.left &&
                        playerRightSide > wallLeftSide &&
                        playerRightSide < wallRightSide &&
                        playerLeftSide < wallLeftSide &&
                        playerTopSide < wallBottomSide - allowanceBuffer &&
                        playerBottomSide > wallTopSide + allowanceBuffer) {
                        player.velX = 0;
                    }

                    if (!player.direction.down &&
                        playerTopSide > wallTopSide &&
                        playerTopSide < wallBottomSide &&
                        playerBottomSide > wallBottomSide &&
                        playerLeftSide < wallRightSide - allowanceBuffer &&
                        playerRightSide > wallLeftSide + allowanceBuffer) {
                        player.velY = 0;
                    }

                    if (!player.direction.up &&
                        playerBottomSide > wallTopSide &&
                        playerBottomSide < wallBottomSide &&
                        playerTopSide < wallTopSide &&
                        playerLeftSide < wallRightSide - allowanceBuffer &&
                        playerRightSide > wallLeftSide + allowanceBuffer) {
                        player.velY = 0;
                    }
                }

                if (entity.type === ENEMY) {
                    // enemy dies and player gets the points equal to their strength
                    // I could assign a enemy.pointValue if needed instead of their strength?
                    if (player.strength > entity.strength) {
                        var enemies = data.entities.enemiesArray;
                        for (var i = enemies.length - 1; i >= 0; i--) {
                            if (enemies[i].id === entity.id) {
                                player.points += entity.strength;
                                data.entities.enemiesArray.splice(i, 1);
                                break;
                            }
                        }
                    }
                    // player loses a life and enters ghost state for a short time
                    // the enemy freezes momentarily while the player escapes
                    else {
                        player.lives--;

                        // check if game is over
                        if (player.lives < 1) {
                            data.gameOver = true;
                            data.gameRunning = false;
                        }

                        player.inGhostState = true;
                        player.enteredGhostStateTimestamp = new Date().getTime();

                        // freezes all enemies once the player is hit
                        data.entities.enemiesArray.forEach(function (enemy) {
                            enemy.frozen = true;
                            enemy.frozenTimestamp = new Date().getTime();
                        })

                        // freezes just the enemy that hit the player
                        // entity.frozen = true;
                        // entity.frozenTimestamp = new Date().getTime();
                    }
                }
            }
        }

        // Game Script
        var Game = {
            init: function () {
                var cv = document.getElementById('gameCanvas');
                var ctx = cv.getContext('2d');

                var canvas = {
                    canvas: cv,
                    context: ctx
                }

                var data = {
                    animationFrame: 0,
                    canvas: canvas,
                    gameOver: false,
                    gameRunning: true
                }

                Entities.init(data);
                Input.init(data);
                Render.init(data);

                Game.run(data);
            },

            run: function (data) {
                var loop = function () {
                    // end the loop if game is over
                    if (data.gameOver) {
                        Game.showGameOver(data);
                        return;
                    }

                    // if game is not paused, update things
                    if (data.gameRunning) {
                        Game.input(data);
                        Game.update(data);
                        Game.render(data);
                    } else {
                        Game.showMenu(data);
                    }

                    // keep the loop going
                    data.animationFrame++;
                    window.requestAnimationFrame(loop);
                }

                loop();
            },

            input: function (data) {
                Input.update(data);
            },

            update: function (data) {
                Entities.update(data);
                Physics.update(data);
            },

            render: function (data) {
                Render.update(data);
            },

            showGameOver(data) {
                Render.helpers.drawText({
                    x: 200,
                    y: 300,
                    size: '40px',
                    value: 'Game Over. Final Score: ' + data.entities.player.points
                })
            },

            showMenu(data) {
                Render.clearCanvas(data.canvas);
                // title
                Render.helpers.drawText({
                    x: data.canvas.canvas.width / 2 - 80,
                    y: 50,
                    size: '30px',
                    value: 'Shop!!!'
                });
                // Shows the player
                Render.helpers.drawText({
                    x: data.canvas.canvas.width - 240,
                    y: 50,
                    value: 'You'
                });
                Render.helpers.drawText({
                    x: data.canvas.canvas.width - 240,
                    y: 80,
                    value: 'Points: ' + data.entities.player.points
                });
                Render.helpers.drawText({
                    x: data.canvas.canvas.width - 240,
                    y: 110,
                    value: 'Money: $' + data.entities.player.money
                });
                Render.helpers.drawText({
                    x: data.canvas.canvas.width - 240,
                    y: 140,
                    value: 'Strength: ' + data.entities.player.strength
                });
                Render.helpers.drawText({
                    x: data.canvas.canvas.width - 240,
                    y: 170,
                    value: 'Speed: ' + Math.floor(data.entities.player.speed * 100)
                });

                // Trade points for money
                Render.helpers.drawText({
                    x: data.canvas.canvas.width - 300,
                    y: 250,
                    value: 'O: Trade $25 for 4 points'
                })
                Render.helpers.drawText({
                    x: data.canvas.canvas.width - 300,
                    y: 280,
                    value: 'P: Trade $50 for 9 points'
                })
                Render.helpers.drawText({
                    x: data.canvas.canvas.width - 300,
                    y: 310,
                    value: 'K: Trade 4 points for $20'
                })
                Render.helpers.drawText({
                    x: data.canvas.canvas.width - 300,
                    y: 340,
                    value: 'L: Trade 8 points for $42'
                })

                // shop items
                Render.helpers.drawText({
                    x: 50,
                    y: 100,
                    value: 'Q: Strength Potion - 1 strength - $10'
                })
                Render.helpers.drawText({
                    x: 50,
                    y: 130,
                    value: 'W: Speed Potion - 20 speed - $10'
                })
                Render.helpers.drawText({
                    x: 50,
                    y: 160,
                    value: 'E: Extra Life - 1 life - $100'
                })
                Render.helpers.drawText({
                    x: 50,
                    y: 190,
                    value: 'R: Food worth more points - $500'
                })
            }
        }

        Game.init();
    </script>

</body>

</html>